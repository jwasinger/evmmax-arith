package mont_arith

import (
	"encoding/binary"
	"errors"
	"fmt"
	"math/bits"
)

func MulMontNonUnrolled64(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [1]uint64

	// conversion to little-endian limb-order, system limb-endianess
    fmt.Printf("jared0. x_bytes=%x\n", x_bytes[0:8])
	x[0] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[0] = binary.BigEndian.Uint64(y_bytes[0:8])
    fmt.Printf("jared0. x=%x\n", x[0])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:8])
	   yInt := new(big.Int).SetBytes(y_bytes[0:8])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [2]uint64
	var D uint64
	var m, C uint64

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])

	t[1], D = bits.Add64(t[1], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	t[0], C = bits.Add64(t[1], C, 0)
	t[1], _ = bits.Add64(0, D, C)

	for j := 1; j < 1; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		t[1], D = bits.Add64(t[1], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		t[0], C = bits.Add64(t[1], C, 0)
		t[1], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)

    fmt.Println("jared")
    fmt.Println(z[0])
    fmt.Println(t[0])

	var src []uint64
	if D != 0 && t[1] == 0 {
		src = t[:1]
	} else {
		src = z[:]
	}
    fmt.Println(src[0])
	binary.BigEndian.PutUint64(z_bytes[0:8], src[0])
    fmt.Printf("z_bytes are %x\n", z_bytes[0:8])

	return nil
}

func MulMontNonUnrolled128(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [2]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[1] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[1] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[0] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[0] = binary.BigEndian.Uint64(y_bytes[8:16])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:16])
	   yInt := new(big.Int).SetBytes(y_bytes[0:16])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [3]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 2")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)

	t[2], D = bits.Add64(t[2], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	t[1], C = bits.Add64(t[2], C, 0)
	t[2], _ = bits.Add64(0, D, C)

	for j := 1; j < 2; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		t[2], D = bits.Add64(t[2], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		t[1], C = bits.Add64(t[2], C, 0)
		t[2], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)

	var src []uint64
	if D != 0 && t[2] == 0 {
		src = t[:2]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[1])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[0])

	return nil
}

func MulMontNonUnrolled192(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [3]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[2] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[2] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[1] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[1] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[0] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[0] = binary.BigEndian.Uint64(y_bytes[16:24])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:24])
	   yInt := new(big.Int).SetBytes(y_bytes[0:24])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [4]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 3")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)

	t[3], D = bits.Add64(t[3], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	t[2], C = bits.Add64(t[3], C, 0)
	t[3], _ = bits.Add64(0, D, C)

	for j := 1; j < 3; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		t[3], D = bits.Add64(t[3], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		t[2], C = bits.Add64(t[3], C, 0)
		t[3], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)

	var src []uint64
	if D != 0 && t[3] == 0 {
		src = t[:3]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[2])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[1])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[0])

	return nil
}

func MulMontNonUnrolled256(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [4]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[3] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[3] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[2] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[2] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[1] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[1] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[0] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[0] = binary.BigEndian.Uint64(y_bytes[24:32])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:32])
	   yInt := new(big.Int).SetBytes(y_bytes[0:32])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [5]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 4")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)

	t[4], D = bits.Add64(t[4], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	t[3], C = bits.Add64(t[4], C, 0)
	t[4], _ = bits.Add64(0, D, C)

	for j := 1; j < 4; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		t[4], D = bits.Add64(t[4], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		t[3], C = bits.Add64(t[4], C, 0)
		t[4], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)

	var src []uint64
	if D != 0 && t[4] == 0 {
		src = t[:4]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[3])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[2])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[1])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[0])

	return nil
}

func MulMontNonUnrolled320(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [5]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[4] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[4] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[3] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[3] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[2] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[2] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[1] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[1] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[0] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[0] = binary.BigEndian.Uint64(y_bytes[32:40])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:40])
	   yInt := new(big.Int).SetBytes(y_bytes[0:40])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [6]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 5")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)

	t[5], D = bits.Add64(t[5], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	t[4], C = bits.Add64(t[5], C, 0)
	t[5], _ = bits.Add64(0, D, C)

	for j := 1; j < 5; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		t[5], D = bits.Add64(t[5], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		t[4], C = bits.Add64(t[5], C, 0)
		t[5], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)

	var src []uint64
	if D != 0 && t[5] == 0 {
		src = t[:5]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[4])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[3])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[2])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[1])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[0])

	return nil
}

func MulMontNonUnrolled384(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [6]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[5] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[5] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[4] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[4] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[3] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[3] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[2] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[2] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[1] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[1] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[0] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[0] = binary.BigEndian.Uint64(y_bytes[40:48])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:48])
	   yInt := new(big.Int).SetBytes(y_bytes[0:48])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [7]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 6")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)

	t[6], D = bits.Add64(t[6], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	t[5], C = bits.Add64(t[6], C, 0)
	t[6], _ = bits.Add64(0, D, C)

	for j := 1; j < 6; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		t[6], D = bits.Add64(t[6], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		t[5], C = bits.Add64(t[6], C, 0)
		t[6], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)

	var src []uint64
	if D != 0 && t[6] == 0 {
		src = t[:6]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[5])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[4])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[3])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[2])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[1])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[0])

	return nil
}

func MulMontNonUnrolled448(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [7]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[6] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[6] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[5] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[5] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[4] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[4] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[3] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[3] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[2] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[2] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[1] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[1] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[0] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[0] = binary.BigEndian.Uint64(y_bytes[48:56])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:56])
	   yInt := new(big.Int).SetBytes(y_bytes[0:56])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [8]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 7")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)

	t[7], D = bits.Add64(t[7], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	t[6], C = bits.Add64(t[7], C, 0)
	t[7], _ = bits.Add64(0, D, C)

	for j := 1; j < 7; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		t[7], D = bits.Add64(t[7], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		t[6], C = bits.Add64(t[7], C, 0)
		t[7], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)

	var src []uint64
	if D != 0 && t[7] == 0 {
		src = t[:7]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[6])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[5])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[4])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[3])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[2])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[1])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[0])

	return nil
}

func MulMontNonUnrolled512(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [8]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[7] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[7] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[6] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[6] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[5] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[5] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[4] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[4] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[3] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[3] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[2] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[2] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[1] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[1] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[0] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[0] = binary.BigEndian.Uint64(y_bytes[56:64])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:64])
	   yInt := new(big.Int).SetBytes(y_bytes[0:64])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [9]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 8")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)

	t[8], D = bits.Add64(t[8], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	t[7], C = bits.Add64(t[8], C, 0)
	t[8], _ = bits.Add64(0, D, C)

	for j := 1; j < 8; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		t[8], D = bits.Add64(t[8], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		t[7], C = bits.Add64(t[8], C, 0)
		t[8], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)

	var src []uint64
	if D != 0 && t[8] == 0 {
		src = t[:8]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[7])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[6])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[5])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[4])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[3])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[2])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[1])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[0])

	return nil
}

func MulMontNonUnrolled576(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [9]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[8] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[8] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[7] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[7] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[6] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[6] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[5] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[5] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[4] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[4] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[3] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[3] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[2] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[2] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[1] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[1] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[0] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[0] = binary.BigEndian.Uint64(y_bytes[64:72])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:72])
	   yInt := new(big.Int).SetBytes(y_bytes[0:72])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [10]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 9")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)

	t[9], D = bits.Add64(t[9], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	t[8], C = bits.Add64(t[9], C, 0)
	t[9], _ = bits.Add64(0, D, C)

	for j := 1; j < 9; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		t[9], D = bits.Add64(t[9], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		t[8], C = bits.Add64(t[9], C, 0)
		t[9], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)

	var src []uint64
	if D != 0 && t[9] == 0 {
		src = t[:9]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[8])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[7])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[6])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[5])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[4])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[3])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[2])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[1])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[0])

	return nil
}

func MulMontNonUnrolled640(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [10]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[9] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[9] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[8] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[8] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[7] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[7] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[6] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[6] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[5] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[5] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[4] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[4] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[3] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[3] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[2] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[2] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[1] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[1] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[0] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[0] = binary.BigEndian.Uint64(y_bytes[72:80])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:80])
	   yInt := new(big.Int).SetBytes(y_bytes[0:80])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [11]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 10")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)

	t[10], D = bits.Add64(t[10], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	t[9], C = bits.Add64(t[10], C, 0)
	t[10], _ = bits.Add64(0, D, C)

	for j := 1; j < 10; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		t[10], D = bits.Add64(t[10], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		t[9], C = bits.Add64(t[10], C, 0)
		t[10], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)

	var src []uint64
	if D != 0 && t[10] == 0 {
		src = t[:10]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[9])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[8])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[7])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[6])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[5])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[4])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[3])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[2])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[1])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[0])

	return nil
}

func MulMontNonUnrolled704(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [11]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[10] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[10] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[9] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[9] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[8] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[8] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[7] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[7] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[6] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[6] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[5] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[5] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[4] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[4] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[3] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[3] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[2] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[2] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[1] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[1] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[0] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[0] = binary.BigEndian.Uint64(y_bytes[80:88])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:88])
	   yInt := new(big.Int).SetBytes(y_bytes[0:88])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [12]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 11")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)

	t[11], D = bits.Add64(t[11], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	t[10], C = bits.Add64(t[11], C, 0)
	t[11], _ = bits.Add64(0, D, C)

	for j := 1; j < 11; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		t[11], D = bits.Add64(t[11], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		t[10], C = bits.Add64(t[11], C, 0)
		t[11], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)

	var src []uint64
	if D != 0 && t[11] == 0 {
		src = t[:11]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[10])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[9])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[8])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[7])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[6])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[5])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[4])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[3])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[2])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[1])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[0])

	return nil
}

func MulMontNonUnrolled768(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [12]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[11] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[11] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[10] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[10] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[9] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[9] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[8] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[8] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[7] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[7] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[6] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[6] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[5] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[5] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[4] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[4] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[3] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[3] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[2] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[2] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[1] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[1] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[0] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[0] = binary.BigEndian.Uint64(y_bytes[88:96])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:96])
	   yInt := new(big.Int).SetBytes(y_bytes[0:96])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [13]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 12")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)

	t[12], D = bits.Add64(t[12], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	t[11], C = bits.Add64(t[12], C, 0)
	t[12], _ = bits.Add64(0, D, C)

	for j := 1; j < 12; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		t[12], D = bits.Add64(t[12], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		t[11], C = bits.Add64(t[12], C, 0)
		t[12], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)

	var src []uint64
	if D != 0 && t[12] == 0 {
		src = t[:12]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[11])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[10])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[9])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[8])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[7])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[6])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[5])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[4])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[3])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[2])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[1])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[0])

	return nil
}

func MulMontNonUnrolled832(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [13]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[12] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[12] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[11] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[11] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[10] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[10] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[9] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[9] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[8] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[8] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[7] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[7] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[6] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[6] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[5] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[5] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[4] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[4] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[3] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[3] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[2] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[2] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[1] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[1] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[0] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[0] = binary.BigEndian.Uint64(y_bytes[96:104])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:104])
	   yInt := new(big.Int).SetBytes(y_bytes[0:104])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [14]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 13")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)

	t[13], D = bits.Add64(t[13], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	t[12], C = bits.Add64(t[13], C, 0)
	t[13], _ = bits.Add64(0, D, C)

	for j := 1; j < 13; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		t[13], D = bits.Add64(t[13], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		t[12], C = bits.Add64(t[13], C, 0)
		t[13], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)

	var src []uint64
	if D != 0 && t[13] == 0 {
		src = t[:13]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[12])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[11])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[10])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[9])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[8])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[7])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[6])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[5])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[4])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[3])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[2])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[1])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[0])

	return nil
}

func MulMontNonUnrolled896(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [14]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[13] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[13] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[12] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[12] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[11] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[11] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[10] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[10] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[9] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[9] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[8] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[8] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[7] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[7] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[6] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[6] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[5] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[5] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[4] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[4] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[3] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[3] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[2] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[2] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[1] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[1] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[0] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[0] = binary.BigEndian.Uint64(y_bytes[104:112])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:112])
	   yInt := new(big.Int).SetBytes(y_bytes[0:112])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [15]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 14")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)

	t[14], D = bits.Add64(t[14], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	t[13], C = bits.Add64(t[14], C, 0)
	t[14], _ = bits.Add64(0, D, C)

	for j := 1; j < 14; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		t[14], D = bits.Add64(t[14], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		t[13], C = bits.Add64(t[14], C, 0)
		t[14], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)

	var src []uint64
	if D != 0 && t[14] == 0 {
		src = t[:14]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[13])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[12])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[11])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[10])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[9])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[8])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[7])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[6])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[5])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[4])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[3])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[2])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[1])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[0])

	return nil
}

func MulMontNonUnrolled960(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [15]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[14] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[14] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[13] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[13] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[12] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[12] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[11] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[11] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[10] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[10] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[9] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[9] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[8] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[8] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[7] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[7] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[6] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[6] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[5] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[5] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[4] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[4] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[3] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[3] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[2] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[2] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[1] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[1] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[0] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[0] = binary.BigEndian.Uint64(y_bytes[112:120])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:120])
	   yInt := new(big.Int).SetBytes(y_bytes[0:120])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [16]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 15")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)

	t[15], D = bits.Add64(t[15], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	t[14], C = bits.Add64(t[15], C, 0)
	t[15], _ = bits.Add64(0, D, C)

	for j := 1; j < 15; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		t[15], D = bits.Add64(t[15], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		t[14], C = bits.Add64(t[15], C, 0)
		t[15], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)

	var src []uint64
	if D != 0 && t[15] == 0 {
		src = t[:15]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[14])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[13])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[12])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[11])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[10])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[9])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[8])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[7])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[6])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[5])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[4])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[3])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[2])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[1])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[0])

	return nil
}

func MulMontNonUnrolled1024(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [16]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[15] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[15] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[14] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[14] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[13] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[13] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[12] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[12] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[11] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[11] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[10] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[10] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[9] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[9] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[8] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[8] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[7] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[7] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[6] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[6] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[5] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[5] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[4] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[4] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[3] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[3] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[2] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[2] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[1] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[1] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[0] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[0] = binary.BigEndian.Uint64(y_bytes[120:128])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:128])
	   yInt := new(big.Int).SetBytes(y_bytes[0:128])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [17]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 16")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)

	t[16], D = bits.Add64(t[16], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	t[15], C = bits.Add64(t[16], C, 0)
	t[16], _ = bits.Add64(0, D, C)

	for j := 1; j < 16; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		t[16], D = bits.Add64(t[16], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		t[15], C = bits.Add64(t[16], C, 0)
		t[16], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)

	var src []uint64
	if D != 0 && t[16] == 0 {
		src = t[:16]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[15])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[14])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[13])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[12])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[11])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[10])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[9])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[8])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[7])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[6])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[5])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[4])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[3])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[2])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[1])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[0])

	return nil
}

func MulMontNonUnrolled1088(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [17]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[16] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[16] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[15] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[15] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[14] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[14] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[13] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[13] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[12] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[12] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[11] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[11] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[10] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[10] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[9] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[9] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[8] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[8] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[7] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[7] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[6] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[6] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[5] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[5] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[4] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[4] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[3] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[3] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[2] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[2] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[1] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[1] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[0] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[0] = binary.BigEndian.Uint64(y_bytes[128:136])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:136])
	   yInt := new(big.Int).SetBytes(y_bytes[0:136])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [18]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 17")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)

	t[17], D = bits.Add64(t[17], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	t[16], C = bits.Add64(t[17], C, 0)
	t[17], _ = bits.Add64(0, D, C)

	for j := 1; j < 17; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		t[17], D = bits.Add64(t[17], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		t[16], C = bits.Add64(t[17], C, 0)
		t[17], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)

	var src []uint64
	if D != 0 && t[17] == 0 {
		src = t[:17]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[16])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[15])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[14])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[13])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[12])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[11])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[10])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[9])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[8])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[7])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[6])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[5])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[4])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[3])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[2])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[1])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[0])

	return nil
}

func MulMontNonUnrolled1152(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [18]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[17] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[17] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[16] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[16] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[15] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[15] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[14] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[14] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[13] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[13] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[12] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[12] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[11] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[11] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[10] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[10] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[9] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[9] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[8] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[8] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[7] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[7] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[6] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[6] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[5] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[5] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[4] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[4] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[3] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[3] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[2] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[2] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[1] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[1] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[0] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[0] = binary.BigEndian.Uint64(y_bytes[136:144])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:144])
	   yInt := new(big.Int).SetBytes(y_bytes[0:144])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [19]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 18")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)

	t[18], D = bits.Add64(t[18], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	t[17], C = bits.Add64(t[18], C, 0)
	t[18], _ = bits.Add64(0, D, C)

	for j := 1; j < 18; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		t[18], D = bits.Add64(t[18], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		t[17], C = bits.Add64(t[18], C, 0)
		t[18], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)

	var src []uint64
	if D != 0 && t[18] == 0 {
		src = t[:18]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[17])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[16])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[15])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[14])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[13])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[12])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[11])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[10])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[9])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[8])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[7])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[6])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[5])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[4])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[3])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[2])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[1])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[0])

	return nil
}

func MulMontNonUnrolled1216(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [19]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[18] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[18] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[17] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[17] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[16] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[16] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[15] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[15] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[14] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[14] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[13] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[13] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[12] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[12] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[11] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[11] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[10] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[10] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[9] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[9] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[8] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[8] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[7] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[7] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[6] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[6] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[5] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[5] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[4] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[4] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[3] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[3] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[2] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[2] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[1] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[1] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[0] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[0] = binary.BigEndian.Uint64(y_bytes[144:152])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:152])
	   yInt := new(big.Int).SetBytes(y_bytes[0:152])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [20]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 19")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)

	t[19], D = bits.Add64(t[19], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	t[18], C = bits.Add64(t[19], C, 0)
	t[19], _ = bits.Add64(0, D, C)

	for j := 1; j < 19; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		t[19], D = bits.Add64(t[19], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		t[18], C = bits.Add64(t[19], C, 0)
		t[19], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)

	var src []uint64
	if D != 0 && t[19] == 0 {
		src = t[:19]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[18])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[17])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[16])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[15])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[14])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[13])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[12])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[11])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[10])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[9])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[8])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[7])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[6])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[5])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[4])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[3])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[2])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[1])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[0])

	return nil
}

func MulMontNonUnrolled1280(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [20]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[19] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[19] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[18] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[18] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[17] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[17] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[16] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[16] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[15] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[15] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[14] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[14] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[13] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[13] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[12] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[12] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[11] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[11] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[10] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[10] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[9] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[9] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[8] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[8] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[7] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[7] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[6] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[6] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[5] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[5] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[4] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[4] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[3] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[3] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[2] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[2] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[1] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[1] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[0] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[0] = binary.BigEndian.Uint64(y_bytes[152:160])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:160])
	   yInt := new(big.Int).SetBytes(y_bytes[0:160])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [21]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 20")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)

	t[20], D = bits.Add64(t[20], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	t[19], C = bits.Add64(t[20], C, 0)
	t[20], _ = bits.Add64(0, D, C)

	for j := 1; j < 20; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		t[20], D = bits.Add64(t[20], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		t[19], C = bits.Add64(t[20], C, 0)
		t[20], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)

	var src []uint64
	if D != 0 && t[20] == 0 {
		src = t[:20]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[19])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[18])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[17])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[16])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[15])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[14])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[13])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[12])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[11])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[10])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[9])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[8])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[7])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[6])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[5])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[4])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[3])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[2])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[1])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[0])

	return nil
}

func MulMontNonUnrolled1344(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [21]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[20] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[20] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[19] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[19] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[18] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[18] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[17] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[17] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[16] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[16] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[15] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[15] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[14] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[14] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[13] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[13] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[12] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[12] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[11] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[11] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[10] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[10] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[9] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[9] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[8] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[8] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[7] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[7] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[6] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[6] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[5] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[5] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[4] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[4] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[3] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[3] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[2] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[2] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[1] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[1] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[0] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[0] = binary.BigEndian.Uint64(y_bytes[160:168])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:168])
	   yInt := new(big.Int).SetBytes(y_bytes[0:168])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [22]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 21")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)

	t[21], D = bits.Add64(t[21], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	t[20], C = bits.Add64(t[21], C, 0)
	t[21], _ = bits.Add64(0, D, C)

	for j := 1; j < 21; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		t[21], D = bits.Add64(t[21], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		t[20], C = bits.Add64(t[21], C, 0)
		t[21], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)

	var src []uint64
	if D != 0 && t[21] == 0 {
		src = t[:21]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[20])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[19])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[18])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[17])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[16])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[15])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[14])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[13])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[12])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[11])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[10])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[9])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[8])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[7])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[6])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[5])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[4])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[3])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[2])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[1])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[0])

	return nil
}

func MulMontNonUnrolled1408(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [22]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[21] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[21] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[20] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[20] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[19] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[19] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[18] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[18] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[17] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[17] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[16] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[16] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[15] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[15] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[14] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[14] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[13] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[13] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[12] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[12] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[11] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[11] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[10] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[10] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[9] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[9] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[8] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[8] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[7] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[7] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[6] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[6] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[5] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[5] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[4] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[4] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[3] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[3] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[2] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[2] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[1] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[1] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[0] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[0] = binary.BigEndian.Uint64(y_bytes[168:176])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:176])
	   yInt := new(big.Int).SetBytes(y_bytes[0:176])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [23]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 22")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)

	t[22], D = bits.Add64(t[22], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	t[21], C = bits.Add64(t[22], C, 0)
	t[22], _ = bits.Add64(0, D, C)

	for j := 1; j < 22; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		t[22], D = bits.Add64(t[22], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		t[21], C = bits.Add64(t[22], C, 0)
		t[22], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)

	var src []uint64
	if D != 0 && t[22] == 0 {
		src = t[:22]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[21])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[20])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[19])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[18])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[17])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[16])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[15])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[14])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[13])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[12])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[11])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[10])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[9])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[8])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[7])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[6])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[5])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[4])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[3])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[2])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[1])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[0])

	return nil
}

func MulMontNonUnrolled1472(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [23]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[22] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[22] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[21] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[21] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[20] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[20] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[19] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[19] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[18] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[18] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[17] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[17] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[16] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[16] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[15] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[15] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[14] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[14] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[13] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[13] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[12] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[12] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[11] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[11] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[10] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[10] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[9] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[9] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[8] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[8] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[7] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[7] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[6] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[6] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[5] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[5] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[4] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[4] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[3] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[3] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[2] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[2] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[1] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[1] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[0] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[0] = binary.BigEndian.Uint64(y_bytes[176:184])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:184])
	   yInt := new(big.Int).SetBytes(y_bytes[0:184])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [24]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 23")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)

	t[23], D = bits.Add64(t[23], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	t[22], C = bits.Add64(t[23], C, 0)
	t[23], _ = bits.Add64(0, D, C)

	for j := 1; j < 23; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		t[23], D = bits.Add64(t[23], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		t[22], C = bits.Add64(t[23], C, 0)
		t[23], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)

	var src []uint64
	if D != 0 && t[23] == 0 {
		src = t[:23]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[22])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[21])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[20])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[19])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[18])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[17])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[16])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[15])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[14])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[13])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[12])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[11])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[10])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[9])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[8])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[7])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[6])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[5])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[4])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[3])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[2])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[1])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[0])

	return nil
}

func MulMontNonUnrolled1536(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [24]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[23] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[23] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[22] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[22] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[21] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[21] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[20] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[20] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[19] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[19] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[18] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[18] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[17] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[17] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[16] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[16] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[15] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[15] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[14] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[14] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[13] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[13] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[12] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[12] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[11] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[11] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[10] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[10] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[9] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[9] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[8] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[8] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[7] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[7] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[6] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[6] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[5] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[5] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[4] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[4] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[3] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[3] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[2] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[2] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[1] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[1] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[0] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[0] = binary.BigEndian.Uint64(y_bytes[184:192])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:192])
	   yInt := new(big.Int).SetBytes(y_bytes[0:192])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [25]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 24")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)

	t[24], D = bits.Add64(t[24], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	t[23], C = bits.Add64(t[24], C, 0)
	t[24], _ = bits.Add64(0, D, C)

	for j := 1; j < 24; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		t[24], D = bits.Add64(t[24], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		t[23], C = bits.Add64(t[24], C, 0)
		t[24], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)

	var src []uint64
	if D != 0 && t[24] == 0 {
		src = t[:24]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[23])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[22])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[21])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[20])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[19])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[18])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[17])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[16])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[15])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[14])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[13])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[12])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[11])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[10])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[9])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[8])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[7])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[6])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[5])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[4])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[3])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[2])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[1])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[0])

	return nil
}

func MulMontNonUnrolled1600(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [25]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[24] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[24] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[23] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[23] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[22] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[22] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[21] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[21] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[20] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[20] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[19] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[19] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[18] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[18] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[17] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[17] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[16] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[16] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[15] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[15] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[14] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[14] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[13] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[13] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[12] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[12] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[11] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[11] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[10] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[10] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[9] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[9] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[8] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[8] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[7] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[7] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[6] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[6] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[5] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[5] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[4] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[4] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[3] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[3] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[2] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[2] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[1] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[1] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[0] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[0] = binary.BigEndian.Uint64(y_bytes[192:200])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:200])
	   yInt := new(big.Int).SetBytes(y_bytes[0:200])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [26]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 25")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)

	t[25], D = bits.Add64(t[25], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	t[24], C = bits.Add64(t[25], C, 0)
	t[25], _ = bits.Add64(0, D, C)

	for j := 1; j < 25; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		t[25], D = bits.Add64(t[25], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		t[24], C = bits.Add64(t[25], C, 0)
		t[25], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)

	var src []uint64
	if D != 0 && t[25] == 0 {
		src = t[:25]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[24])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[23])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[22])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[21])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[20])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[19])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[18])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[17])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[16])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[15])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[14])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[13])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[12])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[11])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[10])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[9])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[8])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[7])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[6])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[5])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[4])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[3])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[2])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[1])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[0])

	return nil
}

func MulMontNonUnrolled1664(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [26]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[25] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[25] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[24] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[24] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[23] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[23] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[22] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[22] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[21] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[21] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[20] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[20] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[19] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[19] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[18] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[18] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[17] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[17] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[16] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[16] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[15] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[15] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[14] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[14] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[13] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[13] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[12] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[12] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[11] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[11] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[10] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[10] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[9] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[9] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[8] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[8] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[7] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[7] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[6] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[6] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[5] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[5] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[4] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[4] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[3] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[3] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[2] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[2] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[1] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[1] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[0] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[0] = binary.BigEndian.Uint64(y_bytes[200:208])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:208])
	   yInt := new(big.Int).SetBytes(y_bytes[0:208])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [27]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 26")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)

	t[26], D = bits.Add64(t[26], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	t[25], C = bits.Add64(t[26], C, 0)
	t[26], _ = bits.Add64(0, D, C)

	for j := 1; j < 26; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		t[26], D = bits.Add64(t[26], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		t[25], C = bits.Add64(t[26], C, 0)
		t[26], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)

	var src []uint64
	if D != 0 && t[26] == 0 {
		src = t[:26]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[25])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[24])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[23])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[22])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[21])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[20])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[19])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[18])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[17])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[16])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[15])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[14])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[13])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[12])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[11])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[10])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[9])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[8])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[7])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[6])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[5])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[4])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[3])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[2])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[1])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[0])

	return nil
}

func MulMontNonUnrolled1728(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [27]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[26] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[26] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[25] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[25] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[24] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[24] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[23] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[23] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[22] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[22] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[21] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[21] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[20] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[20] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[19] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[19] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[18] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[18] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[17] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[17] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[16] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[16] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[15] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[15] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[14] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[14] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[13] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[13] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[12] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[12] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[11] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[11] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[10] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[10] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[9] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[9] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[8] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[8] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[7] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[7] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[6] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[6] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[5] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[5] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[4] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[4] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[3] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[3] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[2] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[2] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[1] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[1] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[0] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[0] = binary.BigEndian.Uint64(y_bytes[208:216])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:216])
	   yInt := new(big.Int).SetBytes(y_bytes[0:216])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [28]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 27")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)

	t[27], D = bits.Add64(t[27], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	t[26], C = bits.Add64(t[27], C, 0)
	t[27], _ = bits.Add64(0, D, C)

	for j := 1; j < 27; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		t[27], D = bits.Add64(t[27], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		t[26], C = bits.Add64(t[27], C, 0)
		t[27], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)

	var src []uint64
	if D != 0 && t[27] == 0 {
		src = t[:27]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[26])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[25])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[24])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[23])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[22])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[21])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[20])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[19])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[18])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[17])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[16])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[15])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[14])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[13])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[12])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[11])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[10])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[9])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[8])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[7])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[6])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[5])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[4])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[3])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[2])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[1])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[0])

	return nil
}

func MulMontNonUnrolled1792(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [28]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[27] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[27] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[26] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[26] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[25] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[25] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[24] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[24] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[23] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[23] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[22] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[22] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[21] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[21] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[20] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[20] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[19] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[19] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[18] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[18] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[17] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[17] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[16] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[16] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[15] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[15] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[14] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[14] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[13] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[13] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[12] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[12] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[11] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[11] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[10] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[10] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[9] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[9] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[8] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[8] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[7] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[7] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[6] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[6] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[5] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[5] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[4] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[4] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[3] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[3] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[2] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[2] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[1] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[1] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[0] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[0] = binary.BigEndian.Uint64(y_bytes[216:224])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:224])
	   yInt := new(big.Int).SetBytes(y_bytes[0:224])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [29]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 28")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)

	t[28], D = bits.Add64(t[28], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	t[27], C = bits.Add64(t[28], C, 0)
	t[28], _ = bits.Add64(0, D, C)

	for j := 1; j < 28; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		t[28], D = bits.Add64(t[28], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		t[27], C = bits.Add64(t[28], C, 0)
		t[28], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)

	var src []uint64
	if D != 0 && t[28] == 0 {
		src = t[:28]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[27])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[26])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[25])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[24])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[23])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[22])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[21])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[20])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[19])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[18])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[17])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[16])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[15])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[14])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[13])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[12])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[11])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[10])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[9])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[8])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[7])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[6])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[5])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[4])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[3])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[2])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[1])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[0])

	return nil
}

func MulMontNonUnrolled1856(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [29]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[28] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[28] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[27] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[27] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[26] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[26] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[25] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[25] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[24] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[24] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[23] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[23] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[22] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[22] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[21] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[21] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[20] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[20] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[19] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[19] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[18] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[18] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[17] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[17] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[16] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[16] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[15] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[15] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[14] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[14] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[13] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[13] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[12] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[12] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[11] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[11] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[10] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[10] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[9] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[9] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[8] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[8] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[7] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[7] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[6] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[6] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[5] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[5] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[4] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[4] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[3] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[3] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[2] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[2] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[1] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[1] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[0] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[0] = binary.BigEndian.Uint64(y_bytes[224:232])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:232])
	   yInt := new(big.Int).SetBytes(y_bytes[0:232])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [30]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 29")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)

	t[29], D = bits.Add64(t[29], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	t[28], C = bits.Add64(t[29], C, 0)
	t[29], _ = bits.Add64(0, D, C)

	for j := 1; j < 29; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		t[29], D = bits.Add64(t[29], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		t[28], C = bits.Add64(t[29], C, 0)
		t[29], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)

	var src []uint64
	if D != 0 && t[29] == 0 {
		src = t[:29]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[28])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[27])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[26])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[25])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[24])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[23])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[22])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[21])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[20])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[19])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[18])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[17])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[16])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[15])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[14])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[13])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[12])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[11])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[10])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[9])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[8])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[7])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[6])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[5])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[4])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[3])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[2])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[1])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[0])

	return nil
}

func MulMontNonUnrolled1920(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [30]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[29] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[29] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[28] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[28] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[27] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[27] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[26] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[26] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[25] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[25] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[24] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[24] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[23] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[23] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[22] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[22] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[21] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[21] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[20] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[20] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[19] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[19] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[18] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[18] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[17] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[17] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[16] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[16] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[15] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[15] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[14] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[14] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[13] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[13] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[12] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[12] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[11] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[11] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[10] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[10] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[9] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[9] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[8] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[8] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[7] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[7] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[6] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[6] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[5] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[5] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[4] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[4] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[3] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[3] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[2] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[2] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[1] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[1] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[0] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[0] = binary.BigEndian.Uint64(y_bytes[232:240])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:240])
	   yInt := new(big.Int).SetBytes(y_bytes[0:240])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [31]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 30")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)

	t[30], D = bits.Add64(t[30], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	t[29], C = bits.Add64(t[30], C, 0)
	t[30], _ = bits.Add64(0, D, C)

	for j := 1; j < 30; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		t[30], D = bits.Add64(t[30], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		t[29], C = bits.Add64(t[30], C, 0)
		t[30], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)

	var src []uint64
	if D != 0 && t[30] == 0 {
		src = t[:30]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[29])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[28])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[27])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[26])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[25])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[24])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[23])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[22])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[21])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[20])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[19])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[18])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[17])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[16])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[15])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[14])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[13])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[12])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[11])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[10])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[9])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[8])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[7])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[6])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[5])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[4])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[3])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[2])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[1])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[0])

	return nil
}

func MulMontNonUnrolled1984(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [31]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[30] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[30] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[29] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[29] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[28] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[28] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[27] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[27] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[26] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[26] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[25] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[25] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[24] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[24] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[23] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[23] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[22] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[22] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[21] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[21] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[20] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[20] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[19] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[19] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[18] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[18] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[17] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[17] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[16] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[16] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[15] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[15] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[14] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[14] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[13] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[13] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[12] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[12] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[11] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[11] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[10] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[10] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[9] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[9] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[8] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[8] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[7] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[7] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[6] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[6] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[5] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[5] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[4] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[4] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[3] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[3] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[2] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[2] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[1] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[1] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[0] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[0] = binary.BigEndian.Uint64(y_bytes[240:248])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:248])
	   yInt := new(big.Int).SetBytes(y_bytes[0:248])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [32]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 31")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)

	t[31], D = bits.Add64(t[31], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	t[30], C = bits.Add64(t[31], C, 0)
	t[31], _ = bits.Add64(0, D, C)

	for j := 1; j < 31; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		t[31], D = bits.Add64(t[31], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		t[30], C = bits.Add64(t[31], C, 0)
		t[31], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)

	var src []uint64
	if D != 0 && t[31] == 0 {
		src = t[:31]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[30])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[29])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[28])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[27])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[26])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[25])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[24])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[23])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[22])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[21])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[20])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[19])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[18])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[17])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[16])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[15])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[14])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[13])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[12])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[11])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[10])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[9])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[8])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[7])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[6])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[5])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[4])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[3])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[2])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[1])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[0])

	return nil
}

func MulMontNonUnrolled2048(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [32]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[31] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[31] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[30] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[30] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[29] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[29] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[28] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[28] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[27] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[27] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[26] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[26] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[25] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[25] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[24] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[24] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[23] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[23] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[22] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[22] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[21] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[21] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[20] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[20] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[19] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[19] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[18] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[18] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[17] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[17] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[16] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[16] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[15] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[15] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[14] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[14] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[13] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[13] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[12] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[12] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[11] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[11] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[10] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[10] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[9] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[9] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[8] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[8] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[7] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[7] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[6] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[6] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[5] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[5] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[4] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[4] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[3] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[3] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[2] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[2] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[1] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[1] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[0] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[0] = binary.BigEndian.Uint64(y_bytes[248:256])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:256])
	   yInt := new(big.Int).SetBytes(y_bytes[0:256])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [33]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 32")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)

	t[32], D = bits.Add64(t[32], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	t[31], C = bits.Add64(t[32], C, 0)
	t[32], _ = bits.Add64(0, D, C)

	for j := 1; j < 32; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		t[32], D = bits.Add64(t[32], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		t[31], C = bits.Add64(t[32], C, 0)
		t[32], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)

	var src []uint64
	if D != 0 && t[32] == 0 {
		src = t[:32]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[31])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[30])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[29])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[28])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[27])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[26])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[25])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[24])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[23])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[22])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[21])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[20])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[19])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[18])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[17])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[16])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[15])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[14])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[13])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[12])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[11])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[10])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[9])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[8])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[7])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[6])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[5])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[4])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[3])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[2])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[1])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[0])

	return nil
}

func MulMontNonUnrolled2112(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [33]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[32] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[32] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[31] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[31] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[30] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[30] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[29] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[29] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[28] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[28] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[27] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[27] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[26] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[26] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[25] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[25] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[24] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[24] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[23] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[23] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[22] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[22] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[21] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[21] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[20] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[20] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[19] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[19] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[18] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[18] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[17] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[17] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[16] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[16] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[15] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[15] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[14] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[14] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[13] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[13] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[12] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[12] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[11] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[11] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[10] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[10] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[9] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[9] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[8] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[8] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[7] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[7] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[6] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[6] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[5] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[5] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[4] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[4] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[3] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[3] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[2] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[2] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[1] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[1] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[0] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[0] = binary.BigEndian.Uint64(y_bytes[256:264])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:264])
	   yInt := new(big.Int).SetBytes(y_bytes[0:264])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [34]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 33")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)

	t[33], D = bits.Add64(t[33], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	t[32], C = bits.Add64(t[33], C, 0)
	t[33], _ = bits.Add64(0, D, C)

	for j := 1; j < 33; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		t[33], D = bits.Add64(t[33], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		t[32], C = bits.Add64(t[33], C, 0)
		t[33], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)

	var src []uint64
	if D != 0 && t[33] == 0 {
		src = t[:33]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[32])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[31])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[30])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[29])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[28])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[27])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[26])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[25])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[24])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[23])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[22])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[21])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[20])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[19])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[18])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[17])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[16])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[15])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[14])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[13])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[12])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[11])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[10])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[9])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[8])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[7])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[6])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[5])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[4])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[3])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[2])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[1])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[0])

	return nil
}

func MulMontNonUnrolled2176(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [34]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[33] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[33] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[32] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[32] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[31] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[31] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[30] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[30] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[29] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[29] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[28] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[28] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[27] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[27] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[26] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[26] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[25] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[25] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[24] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[24] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[23] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[23] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[22] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[22] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[21] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[21] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[20] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[20] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[19] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[19] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[18] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[18] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[17] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[17] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[16] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[16] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[15] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[15] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[14] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[14] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[13] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[13] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[12] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[12] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[11] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[11] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[10] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[10] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[9] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[9] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[8] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[8] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[7] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[7] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[6] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[6] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[5] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[5] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[4] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[4] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[3] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[3] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[2] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[2] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[1] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[1] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[0] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[0] = binary.BigEndian.Uint64(y_bytes[264:272])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:272])
	   yInt := new(big.Int).SetBytes(y_bytes[0:272])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [35]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 34")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)

	t[34], D = bits.Add64(t[34], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	t[33], C = bits.Add64(t[34], C, 0)
	t[34], _ = bits.Add64(0, D, C)

	for j := 1; j < 34; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		t[34], D = bits.Add64(t[34], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		t[33], C = bits.Add64(t[34], C, 0)
		t[34], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)

	var src []uint64
	if D != 0 && t[34] == 0 {
		src = t[:34]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[33])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[32])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[31])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[30])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[29])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[28])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[27])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[26])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[25])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[24])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[23])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[22])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[21])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[20])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[19])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[18])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[17])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[16])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[15])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[14])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[13])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[12])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[11])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[10])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[9])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[8])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[7])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[6])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[5])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[4])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[3])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[2])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[1])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[0])

	return nil
}

func MulMontNonUnrolled2240(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [35]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[34] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[34] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[33] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[33] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[32] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[32] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[31] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[31] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[30] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[30] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[29] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[29] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[28] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[28] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[27] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[27] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[26] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[26] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[25] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[25] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[24] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[24] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[23] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[23] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[22] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[22] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[21] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[21] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[20] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[20] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[19] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[19] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[18] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[18] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[17] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[17] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[16] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[16] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[15] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[15] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[14] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[14] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[13] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[13] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[12] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[12] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[11] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[11] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[10] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[10] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[9] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[9] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[8] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[8] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[7] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[7] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[6] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[6] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[5] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[5] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[4] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[4] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[3] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[3] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[2] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[2] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[1] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[1] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[0] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[0] = binary.BigEndian.Uint64(y_bytes[272:280])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:280])
	   yInt := new(big.Int).SetBytes(y_bytes[0:280])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [36]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 35")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)

	t[35], D = bits.Add64(t[35], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	t[34], C = bits.Add64(t[35], C, 0)
	t[35], _ = bits.Add64(0, D, C)

	for j := 1; j < 35; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		t[35], D = bits.Add64(t[35], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		t[34], C = bits.Add64(t[35], C, 0)
		t[35], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)

	var src []uint64
	if D != 0 && t[35] == 0 {
		src = t[:35]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[34])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[33])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[32])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[31])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[30])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[29])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[28])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[27])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[26])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[25])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[24])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[23])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[22])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[21])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[20])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[19])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[18])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[17])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[16])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[15])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[14])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[13])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[12])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[11])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[10])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[9])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[8])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[7])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[6])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[5])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[4])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[3])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[2])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[1])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[0])

	return nil
}

func MulMontNonUnrolled2304(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [36]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[35] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[35] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[34] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[34] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[33] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[33] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[32] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[32] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[31] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[31] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[30] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[30] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[29] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[29] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[28] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[28] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[27] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[27] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[26] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[26] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[25] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[25] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[24] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[24] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[23] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[23] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[22] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[22] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[21] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[21] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[20] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[20] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[19] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[19] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[18] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[18] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[17] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[17] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[16] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[16] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[15] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[15] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[14] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[14] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[13] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[13] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[12] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[12] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[11] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[11] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[10] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[10] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[9] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[9] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[8] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[8] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[7] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[7] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[6] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[6] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[5] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[5] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[4] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[4] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[3] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[3] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[2] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[2] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[1] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[1] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[0] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[0] = binary.BigEndian.Uint64(y_bytes[280:288])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:288])
	   yInt := new(big.Int).SetBytes(y_bytes[0:288])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [37]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 36")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)

	t[36], D = bits.Add64(t[36], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	t[35], C = bits.Add64(t[36], C, 0)
	t[36], _ = bits.Add64(0, D, C)

	for j := 1; j < 36; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		t[36], D = bits.Add64(t[36], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		t[35], C = bits.Add64(t[36], C, 0)
		t[36], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)

	var src []uint64
	if D != 0 && t[36] == 0 {
		src = t[:36]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[35])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[34])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[33])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[32])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[31])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[30])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[29])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[28])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[27])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[26])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[25])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[24])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[23])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[22])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[21])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[20])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[19])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[18])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[17])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[16])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[15])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[14])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[13])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[12])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[11])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[10])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[9])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[8])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[7])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[6])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[5])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[4])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[3])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[2])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[1])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[0])

	return nil
}

func MulMontNonUnrolled2368(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [37]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[36] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[36] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[35] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[35] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[34] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[34] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[33] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[33] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[32] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[32] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[31] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[31] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[30] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[30] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[29] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[29] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[28] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[28] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[27] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[27] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[26] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[26] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[25] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[25] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[24] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[24] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[23] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[23] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[22] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[22] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[21] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[21] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[20] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[20] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[19] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[19] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[18] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[18] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[17] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[17] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[16] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[16] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[15] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[15] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[14] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[14] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[13] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[13] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[12] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[12] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[11] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[11] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[10] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[10] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[9] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[9] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[8] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[8] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[7] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[7] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[6] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[6] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[5] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[5] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[4] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[4] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[3] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[3] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[2] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[2] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[1] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[1] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[0] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[0] = binary.BigEndian.Uint64(y_bytes[288:296])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:296])
	   yInt := new(big.Int).SetBytes(y_bytes[0:296])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [38]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 37")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)

	t[37], D = bits.Add64(t[37], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	t[36], C = bits.Add64(t[37], C, 0)
	t[37], _ = bits.Add64(0, D, C)

	for j := 1; j < 37; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		t[37], D = bits.Add64(t[37], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		t[36], C = bits.Add64(t[37], C, 0)
		t[37], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)

	var src []uint64
	if D != 0 && t[37] == 0 {
		src = t[:37]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[36])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[35])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[34])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[33])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[32])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[31])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[30])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[29])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[28])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[27])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[26])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[25])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[24])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[23])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[22])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[21])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[20])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[19])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[18])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[17])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[16])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[15])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[14])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[13])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[12])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[11])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[10])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[9])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[8])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[7])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[6])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[5])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[4])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[3])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[2])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[1])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[0])

	return nil
}

func MulMontNonUnrolled2432(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [38]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[37] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[37] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[36] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[36] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[35] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[35] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[34] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[34] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[33] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[33] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[32] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[32] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[31] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[31] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[30] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[30] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[29] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[29] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[28] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[28] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[27] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[27] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[26] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[26] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[25] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[25] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[24] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[24] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[23] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[23] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[22] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[22] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[21] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[21] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[20] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[20] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[19] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[19] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[18] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[18] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[17] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[17] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[16] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[16] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[15] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[15] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[14] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[14] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[13] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[13] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[12] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[12] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[11] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[11] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[10] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[10] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[9] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[9] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[8] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[8] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[7] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[7] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[6] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[6] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[5] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[5] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[4] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[4] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[3] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[3] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[2] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[2] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[1] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[1] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[0] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[0] = binary.BigEndian.Uint64(y_bytes[296:304])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:304])
	   yInt := new(big.Int).SetBytes(y_bytes[0:304])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [39]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 38")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)

	t[38], D = bits.Add64(t[38], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	t[37], C = bits.Add64(t[38], C, 0)
	t[38], _ = bits.Add64(0, D, C)

	for j := 1; j < 38; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		t[38], D = bits.Add64(t[38], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		t[37], C = bits.Add64(t[38], C, 0)
		t[38], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)

	var src []uint64
	if D != 0 && t[38] == 0 {
		src = t[:38]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[37])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[36])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[35])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[34])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[33])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[32])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[31])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[30])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[29])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[28])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[27])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[26])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[25])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[24])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[23])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[22])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[21])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[20])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[19])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[18])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[17])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[16])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[15])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[14])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[13])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[12])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[11])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[10])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[9])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[8])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[7])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[6])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[5])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[4])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[3])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[2])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[1])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[0])

	return nil
}

func MulMontNonUnrolled2496(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [39]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[38] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[38] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[37] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[37] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[36] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[36] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[35] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[35] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[34] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[34] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[33] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[33] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[32] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[32] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[31] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[31] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[30] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[30] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[29] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[29] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[28] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[28] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[27] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[27] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[26] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[26] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[25] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[25] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[24] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[24] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[23] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[23] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[22] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[22] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[21] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[21] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[20] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[20] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[19] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[19] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[18] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[18] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[17] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[17] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[16] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[16] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[15] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[15] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[14] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[14] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[13] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[13] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[12] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[12] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[11] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[11] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[10] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[10] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[9] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[9] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[8] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[8] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[7] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[7] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[6] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[6] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[5] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[5] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[4] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[4] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[3] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[3] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[2] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[2] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[1] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[1] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[0] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[0] = binary.BigEndian.Uint64(y_bytes[304:312])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:312])
	   yInt := new(big.Int).SetBytes(y_bytes[0:312])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [40]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 39")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)

	t[39], D = bits.Add64(t[39], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	t[38], C = bits.Add64(t[39], C, 0)
	t[39], _ = bits.Add64(0, D, C)

	for j := 1; j < 39; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		t[39], D = bits.Add64(t[39], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		t[38], C = bits.Add64(t[39], C, 0)
		t[39], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)

	var src []uint64
	if D != 0 && t[39] == 0 {
		src = t[:39]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[38])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[37])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[36])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[35])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[34])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[33])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[32])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[31])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[30])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[29])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[28])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[27])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[26])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[25])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[24])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[23])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[22])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[21])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[20])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[19])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[18])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[17])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[16])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[15])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[14])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[13])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[12])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[11])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[10])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[9])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[8])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[7])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[6])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[5])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[4])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[3])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[2])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[1])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[0])

	return nil
}

func MulMontNonUnrolled2560(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [40]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[39] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[39] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[38] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[38] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[37] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[37] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[36] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[36] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[35] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[35] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[34] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[34] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[33] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[33] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[32] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[32] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[31] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[31] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[30] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[30] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[29] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[29] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[28] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[28] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[27] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[27] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[26] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[26] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[25] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[25] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[24] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[24] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[23] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[23] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[22] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[22] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[21] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[21] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[20] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[20] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[19] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[19] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[18] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[18] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[17] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[17] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[16] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[16] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[15] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[15] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[14] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[14] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[13] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[13] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[12] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[12] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[11] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[11] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[10] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[10] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[9] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[9] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[8] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[8] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[7] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[7] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[6] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[6] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[5] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[5] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[4] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[4] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[3] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[3] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[2] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[2] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[1] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[1] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[0] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[0] = binary.BigEndian.Uint64(y_bytes[312:320])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:320])
	   yInt := new(big.Int).SetBytes(y_bytes[0:320])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [41]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 40")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)

	t[40], D = bits.Add64(t[40], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	t[39], C = bits.Add64(t[40], C, 0)
	t[40], _ = bits.Add64(0, D, C)

	for j := 1; j < 40; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		t[40], D = bits.Add64(t[40], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		t[39], C = bits.Add64(t[40], C, 0)
		t[40], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)

	var src []uint64
	if D != 0 && t[40] == 0 {
		src = t[:40]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[39])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[38])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[37])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[36])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[35])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[34])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[33])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[32])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[31])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[30])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[29])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[28])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[27])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[26])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[25])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[24])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[23])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[22])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[21])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[20])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[19])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[18])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[17])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[16])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[15])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[14])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[13])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[12])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[11])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[10])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[9])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[8])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[7])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[6])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[5])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[4])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[3])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[2])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[1])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[0])

	return nil
}

func MulMontNonUnrolled2624(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [41]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[40] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[40] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[39] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[39] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[38] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[38] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[37] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[37] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[36] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[36] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[35] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[35] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[34] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[34] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[33] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[33] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[32] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[32] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[31] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[31] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[30] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[30] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[29] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[29] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[28] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[28] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[27] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[27] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[26] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[26] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[25] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[25] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[24] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[24] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[23] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[23] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[22] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[22] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[21] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[21] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[20] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[20] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[19] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[19] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[18] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[18] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[17] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[17] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[16] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[16] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[15] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[15] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[14] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[14] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[13] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[13] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[12] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[12] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[11] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[11] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[10] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[10] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[9] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[9] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[8] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[8] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[7] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[7] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[6] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[6] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[5] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[5] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[4] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[4] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[3] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[3] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[2] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[2] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[1] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[1] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[0] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[0] = binary.BigEndian.Uint64(y_bytes[320:328])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:328])
	   yInt := new(big.Int).SetBytes(y_bytes[0:328])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [42]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 41")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)

	t[41], D = bits.Add64(t[41], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	t[40], C = bits.Add64(t[41], C, 0)
	t[41], _ = bits.Add64(0, D, C)

	for j := 1; j < 41; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		t[41], D = bits.Add64(t[41], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		t[40], C = bits.Add64(t[41], C, 0)
		t[41], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)

	var src []uint64
	if D != 0 && t[41] == 0 {
		src = t[:41]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[40])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[39])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[38])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[37])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[36])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[35])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[34])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[33])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[32])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[31])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[30])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[29])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[28])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[27])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[26])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[25])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[24])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[23])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[22])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[21])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[20])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[19])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[18])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[17])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[16])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[15])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[14])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[13])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[12])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[11])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[10])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[9])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[8])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[7])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[6])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[5])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[4])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[3])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[2])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[1])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[0])

	return nil
}

func MulMontNonUnrolled2688(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [42]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[41] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[41] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[40] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[40] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[39] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[39] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[38] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[38] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[37] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[37] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[36] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[36] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[35] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[35] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[34] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[34] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[33] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[33] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[32] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[32] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[31] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[31] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[30] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[30] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[29] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[29] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[28] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[28] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[27] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[27] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[26] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[26] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[25] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[25] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[24] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[24] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[23] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[23] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[22] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[22] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[21] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[21] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[20] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[20] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[19] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[19] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[18] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[18] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[17] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[17] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[16] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[16] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[15] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[15] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[14] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[14] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[13] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[13] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[12] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[12] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[11] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[11] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[10] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[10] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[9] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[9] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[8] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[8] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[7] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[7] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[6] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[6] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[5] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[5] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[4] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[4] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[3] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[3] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[2] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[2] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[1] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[1] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[0] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[0] = binary.BigEndian.Uint64(y_bytes[328:336])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:336])
	   yInt := new(big.Int).SetBytes(y_bytes[0:336])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [43]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 42")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)

	t[42], D = bits.Add64(t[42], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	t[41], C = bits.Add64(t[42], C, 0)
	t[42], _ = bits.Add64(0, D, C)

	for j := 1; j < 42; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		t[42], D = bits.Add64(t[42], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		t[41], C = bits.Add64(t[42], C, 0)
		t[42], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)

	var src []uint64
	if D != 0 && t[42] == 0 {
		src = t[:42]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[41])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[40])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[39])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[38])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[37])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[36])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[35])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[34])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[33])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[32])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[31])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[30])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[29])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[28])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[27])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[26])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[25])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[24])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[23])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[22])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[21])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[20])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[19])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[18])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[17])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[16])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[15])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[14])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[13])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[12])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[11])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[10])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[9])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[8])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[7])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[6])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[5])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[4])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[3])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[2])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[1])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[0])

	return nil
}

func MulMontNonUnrolled2752(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [43]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[42] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[42] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[41] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[41] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[40] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[40] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[39] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[39] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[38] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[38] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[37] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[37] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[36] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[36] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[35] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[35] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[34] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[34] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[33] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[33] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[32] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[32] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[31] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[31] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[30] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[30] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[29] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[29] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[28] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[28] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[27] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[27] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[26] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[26] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[25] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[25] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[24] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[24] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[23] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[23] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[22] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[22] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[21] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[21] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[20] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[20] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[19] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[19] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[18] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[18] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[17] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[17] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[16] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[16] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[15] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[15] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[14] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[14] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[13] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[13] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[12] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[12] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[11] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[11] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[10] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[10] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[9] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[9] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[8] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[8] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[7] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[7] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[6] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[6] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[5] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[5] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[4] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[4] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[3] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[3] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[2] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[2] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[1] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[1] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[0] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[0] = binary.BigEndian.Uint64(y_bytes[336:344])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:344])
	   yInt := new(big.Int).SetBytes(y_bytes[0:344])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [44]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 43")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)

	t[43], D = bits.Add64(t[43], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	t[42], C = bits.Add64(t[43], C, 0)
	t[43], _ = bits.Add64(0, D, C)

	for j := 1; j < 43; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		t[43], D = bits.Add64(t[43], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		t[42], C = bits.Add64(t[43], C, 0)
		t[43], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)

	var src []uint64
	if D != 0 && t[43] == 0 {
		src = t[:43]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[42])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[41])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[40])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[39])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[38])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[37])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[36])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[35])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[34])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[33])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[32])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[31])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[30])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[29])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[28])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[27])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[26])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[25])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[24])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[23])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[22])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[21])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[20])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[19])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[18])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[17])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[16])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[15])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[14])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[13])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[12])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[11])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[10])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[9])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[8])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[7])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[6])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[5])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[4])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[3])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[2])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[1])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[0])

	return nil
}

func MulMontNonUnrolled2816(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [44]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[43] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[43] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[42] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[42] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[41] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[41] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[40] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[40] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[39] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[39] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[38] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[38] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[37] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[37] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[36] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[36] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[35] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[35] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[34] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[34] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[33] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[33] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[32] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[32] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[31] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[31] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[30] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[30] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[29] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[29] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[28] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[28] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[27] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[27] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[26] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[26] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[25] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[25] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[24] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[24] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[23] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[23] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[22] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[22] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[21] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[21] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[20] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[20] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[19] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[19] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[18] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[18] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[17] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[17] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[16] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[16] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[15] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[15] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[14] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[14] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[13] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[13] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[12] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[12] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[11] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[11] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[10] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[10] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[9] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[9] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[8] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[8] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[7] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[7] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[6] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[6] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[5] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[5] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[4] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[4] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[3] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[3] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[2] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[2] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[1] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[1] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[0] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[0] = binary.BigEndian.Uint64(y_bytes[344:352])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:352])
	   yInt := new(big.Int).SetBytes(y_bytes[0:352])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [45]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 44")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)

	t[44], D = bits.Add64(t[44], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	t[43], C = bits.Add64(t[44], C, 0)
	t[44], _ = bits.Add64(0, D, C)

	for j := 1; j < 44; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		t[44], D = bits.Add64(t[44], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		t[43], C = bits.Add64(t[44], C, 0)
		t[44], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)

	var src []uint64
	if D != 0 && t[44] == 0 {
		src = t[:44]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[43])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[42])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[41])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[40])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[39])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[38])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[37])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[36])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[35])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[34])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[33])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[32])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[31])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[30])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[29])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[28])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[27])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[26])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[25])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[24])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[23])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[22])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[21])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[20])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[19])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[18])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[17])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[16])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[15])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[14])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[13])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[12])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[11])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[10])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[9])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[8])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[7])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[6])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[5])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[4])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[3])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[2])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[1])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[0])

	return nil
}

func MulMontNonUnrolled2880(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [45]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[44] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[44] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[43] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[43] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[42] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[42] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[41] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[41] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[40] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[40] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[39] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[39] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[38] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[38] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[37] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[37] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[36] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[36] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[35] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[35] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[34] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[34] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[33] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[33] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[32] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[32] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[31] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[31] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[30] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[30] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[29] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[29] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[28] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[28] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[27] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[27] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[26] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[26] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[25] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[25] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[24] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[24] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[23] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[23] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[22] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[22] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[21] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[21] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[20] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[20] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[19] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[19] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[18] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[18] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[17] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[17] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[16] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[16] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[15] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[15] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[14] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[14] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[13] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[13] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[12] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[12] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[11] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[11] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[10] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[10] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[9] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[9] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[8] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[8] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[7] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[7] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[6] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[6] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[5] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[5] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[4] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[4] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[3] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[3] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[2] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[2] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[1] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[1] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[0] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[0] = binary.BigEndian.Uint64(y_bytes[352:360])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:360])
	   yInt := new(big.Int).SetBytes(y_bytes[0:360])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [46]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 45")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)

	t[45], D = bits.Add64(t[45], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	t[44], C = bits.Add64(t[45], C, 0)
	t[45], _ = bits.Add64(0, D, C)

	for j := 1; j < 45; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		t[45], D = bits.Add64(t[45], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		t[44], C = bits.Add64(t[45], C, 0)
		t[45], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)

	var src []uint64
	if D != 0 && t[45] == 0 {
		src = t[:45]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[44])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[43])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[42])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[41])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[40])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[39])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[38])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[37])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[36])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[35])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[34])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[33])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[32])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[31])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[30])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[29])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[28])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[27])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[26])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[25])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[24])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[23])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[22])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[21])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[20])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[19])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[18])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[17])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[16])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[15])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[14])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[13])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[12])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[11])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[10])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[9])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[8])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[7])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[6])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[5])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[4])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[3])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[2])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[1])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[0])

	return nil
}

func MulMontNonUnrolled2944(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [46]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[45] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[45] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[44] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[44] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[43] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[43] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[42] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[42] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[41] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[41] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[40] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[40] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[39] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[39] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[38] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[38] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[37] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[37] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[36] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[36] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[35] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[35] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[34] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[34] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[33] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[33] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[32] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[32] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[31] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[31] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[30] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[30] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[29] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[29] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[28] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[28] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[27] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[27] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[26] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[26] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[25] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[25] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[24] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[24] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[23] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[23] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[22] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[22] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[21] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[21] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[20] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[20] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[19] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[19] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[18] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[18] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[17] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[17] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[16] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[16] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[15] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[15] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[14] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[14] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[13] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[13] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[12] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[12] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[11] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[11] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[10] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[10] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[9] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[9] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[8] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[8] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[7] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[7] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[6] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[6] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[5] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[5] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[4] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[4] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[3] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[3] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[2] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[2] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[1] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[1] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[0] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[0] = binary.BigEndian.Uint64(y_bytes[360:368])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:368])
	   yInt := new(big.Int).SetBytes(y_bytes[0:368])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [47]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 46")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)

	t[46], D = bits.Add64(t[46], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	t[45], C = bits.Add64(t[46], C, 0)
	t[46], _ = bits.Add64(0, D, C)

	for j := 1; j < 46; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		t[46], D = bits.Add64(t[46], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		t[45], C = bits.Add64(t[46], C, 0)
		t[46], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)

	var src []uint64
	if D != 0 && t[46] == 0 {
		src = t[:46]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[45])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[44])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[43])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[42])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[41])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[40])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[39])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[38])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[37])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[36])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[35])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[34])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[33])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[32])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[31])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[30])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[29])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[28])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[27])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[26])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[25])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[24])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[23])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[22])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[21])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[20])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[19])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[18])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[17])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[16])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[15])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[14])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[13])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[12])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[11])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[10])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[9])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[8])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[7])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[6])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[5])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[4])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[3])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[2])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[1])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[0])

	return nil
}

func MulMontNonUnrolled3008(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [47]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[46] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[46] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[45] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[45] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[44] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[44] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[43] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[43] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[42] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[42] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[41] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[41] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[40] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[40] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[39] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[39] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[38] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[38] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[37] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[37] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[36] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[36] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[35] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[35] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[34] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[34] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[33] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[33] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[32] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[32] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[31] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[31] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[30] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[30] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[29] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[29] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[28] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[28] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[27] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[27] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[26] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[26] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[25] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[25] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[24] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[24] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[23] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[23] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[22] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[22] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[21] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[21] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[20] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[20] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[19] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[19] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[18] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[18] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[17] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[17] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[16] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[16] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[15] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[15] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[14] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[14] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[13] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[13] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[12] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[12] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[11] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[11] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[10] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[10] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[9] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[9] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[8] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[8] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[7] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[7] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[6] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[6] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[5] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[5] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[4] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[4] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[3] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[3] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[2] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[2] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[1] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[1] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[0] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[0] = binary.BigEndian.Uint64(y_bytes[368:376])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:376])
	   yInt := new(big.Int).SetBytes(y_bytes[0:376])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [48]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 47")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)

	t[47], D = bits.Add64(t[47], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	t[46], C = bits.Add64(t[47], C, 0)
	t[47], _ = bits.Add64(0, D, C)

	for j := 1; j < 47; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		t[47], D = bits.Add64(t[47], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		t[46], C = bits.Add64(t[47], C, 0)
		t[47], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)

	var src []uint64
	if D != 0 && t[47] == 0 {
		src = t[:47]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[46])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[45])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[44])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[43])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[42])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[41])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[40])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[39])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[38])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[37])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[36])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[35])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[34])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[33])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[32])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[31])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[30])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[29])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[28])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[27])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[26])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[25])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[24])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[23])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[22])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[21])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[20])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[19])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[18])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[17])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[16])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[15])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[14])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[13])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[12])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[11])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[10])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[9])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[8])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[7])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[6])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[5])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[4])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[3])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[2])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[1])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[0])

	return nil
}

func MulMontNonUnrolled3072(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [48]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[47] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[47] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[46] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[46] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[45] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[45] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[44] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[44] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[43] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[43] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[42] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[42] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[41] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[41] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[40] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[40] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[39] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[39] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[38] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[38] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[37] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[37] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[36] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[36] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[35] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[35] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[34] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[34] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[33] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[33] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[32] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[32] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[31] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[31] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[30] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[30] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[29] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[29] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[28] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[28] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[27] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[27] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[26] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[26] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[25] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[25] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[24] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[24] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[23] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[23] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[22] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[22] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[21] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[21] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[20] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[20] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[19] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[19] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[18] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[18] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[17] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[17] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[16] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[16] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[15] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[15] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[14] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[14] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[13] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[13] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[12] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[12] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[11] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[11] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[10] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[10] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[9] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[9] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[8] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[8] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[7] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[7] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[6] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[6] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[5] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[5] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[4] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[4] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[3] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[3] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[2] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[2] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[1] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[1] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[0] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[0] = binary.BigEndian.Uint64(y_bytes[376:384])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:384])
	   yInt := new(big.Int).SetBytes(y_bytes[0:384])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [49]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 48")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)

	t[48], D = bits.Add64(t[48], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	t[47], C = bits.Add64(t[48], C, 0)
	t[48], _ = bits.Add64(0, D, C)

	for j := 1; j < 48; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		t[48], D = bits.Add64(t[48], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		t[47], C = bits.Add64(t[48], C, 0)
		t[48], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)

	var src []uint64
	if D != 0 && t[48] == 0 {
		src = t[:48]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[47])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[46])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[45])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[44])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[43])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[42])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[41])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[40])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[39])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[38])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[37])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[36])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[35])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[34])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[33])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[32])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[31])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[30])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[29])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[28])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[27])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[26])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[25])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[24])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[23])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[22])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[21])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[20])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[19])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[18])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[17])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[16])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[15])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[14])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[13])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[12])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[11])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[10])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[9])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[8])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[7])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[6])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[5])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[4])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[3])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[2])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[1])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[0])

	return nil
}

func MulMontNonUnrolled3136(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [49]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[48] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[48] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[47] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[47] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[46] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[46] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[45] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[45] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[44] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[44] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[43] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[43] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[42] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[42] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[41] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[41] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[40] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[40] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[39] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[39] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[38] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[38] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[37] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[37] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[36] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[36] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[35] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[35] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[34] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[34] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[33] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[33] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[32] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[32] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[31] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[31] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[30] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[30] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[29] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[29] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[28] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[28] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[27] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[27] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[26] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[26] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[25] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[25] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[24] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[24] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[23] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[23] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[22] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[22] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[21] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[21] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[20] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[20] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[19] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[19] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[18] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[18] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[17] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[17] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[16] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[16] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[15] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[15] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[14] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[14] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[13] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[13] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[12] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[12] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[11] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[11] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[10] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[10] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[9] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[9] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[8] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[8] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[7] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[7] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[6] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[6] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[5] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[5] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[4] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[4] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[3] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[3] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[2] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[2] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[1] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[1] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[0] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[0] = binary.BigEndian.Uint64(y_bytes[384:392])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:392])
	   yInt := new(big.Int).SetBytes(y_bytes[0:392])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [50]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 49")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)

	t[49], D = bits.Add64(t[49], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	t[48], C = bits.Add64(t[49], C, 0)
	t[49], _ = bits.Add64(0, D, C)

	for j := 1; j < 49; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		t[49], D = bits.Add64(t[49], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		t[48], C = bits.Add64(t[49], C, 0)
		t[49], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)

	var src []uint64
	if D != 0 && t[49] == 0 {
		src = t[:49]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[48])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[47])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[46])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[45])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[44])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[43])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[42])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[41])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[40])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[39])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[38])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[37])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[36])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[35])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[34])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[33])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[32])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[31])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[30])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[29])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[28])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[27])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[26])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[25])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[24])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[23])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[22])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[21])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[20])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[19])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[18])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[17])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[16])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[15])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[14])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[13])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[12])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[11])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[10])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[9])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[8])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[7])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[6])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[5])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[4])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[3])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[2])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[1])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[0])

	return nil
}

func MulMontNonUnrolled3200(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [50]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[49] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[49] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[48] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[48] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[47] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[47] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[46] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[46] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[45] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[45] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[44] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[44] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[43] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[43] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[42] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[42] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[41] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[41] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[40] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[40] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[39] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[39] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[38] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[38] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[37] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[37] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[36] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[36] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[35] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[35] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[34] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[34] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[33] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[33] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[32] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[32] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[31] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[31] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[30] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[30] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[29] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[29] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[28] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[28] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[27] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[27] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[26] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[26] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[25] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[25] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[24] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[24] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[23] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[23] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[22] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[22] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[21] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[21] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[20] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[20] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[19] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[19] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[18] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[18] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[17] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[17] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[16] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[16] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[15] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[15] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[14] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[14] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[13] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[13] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[12] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[12] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[11] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[11] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[10] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[10] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[9] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[9] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[8] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[8] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[7] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[7] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[6] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[6] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[5] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[5] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[4] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[4] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[3] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[3] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[2] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[2] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[1] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[1] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[0] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[0] = binary.BigEndian.Uint64(y_bytes[392:400])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:400])
	   yInt := new(big.Int).SetBytes(y_bytes[0:400])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [51]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 50")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)

	t[50], D = bits.Add64(t[50], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	t[49], C = bits.Add64(t[50], C, 0)
	t[50], _ = bits.Add64(0, D, C)

	for j := 1; j < 50; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		t[50], D = bits.Add64(t[50], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		t[49], C = bits.Add64(t[50], C, 0)
		t[50], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)

	var src []uint64
	if D != 0 && t[50] == 0 {
		src = t[:50]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[49])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[48])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[47])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[46])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[45])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[44])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[43])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[42])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[41])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[40])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[39])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[38])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[37])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[36])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[35])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[34])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[33])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[32])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[31])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[30])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[29])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[28])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[27])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[26])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[25])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[24])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[23])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[22])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[21])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[20])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[19])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[18])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[17])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[16])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[15])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[14])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[13])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[12])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[11])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[10])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[9])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[8])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[7])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[6])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[5])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[4])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[3])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[2])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[1])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[0])

	return nil
}

func MulMontNonUnrolled3264(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [51]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[50] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[50] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[49] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[49] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[48] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[48] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[47] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[47] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[46] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[46] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[45] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[45] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[44] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[44] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[43] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[43] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[42] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[42] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[41] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[41] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[40] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[40] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[39] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[39] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[38] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[38] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[37] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[37] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[36] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[36] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[35] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[35] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[34] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[34] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[33] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[33] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[32] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[32] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[31] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[31] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[30] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[30] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[29] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[29] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[28] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[28] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[27] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[27] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[26] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[26] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[25] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[25] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[24] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[24] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[23] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[23] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[22] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[22] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[21] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[21] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[20] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[20] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[19] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[19] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[18] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[18] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[17] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[17] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[16] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[16] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[15] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[15] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[14] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[14] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[13] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[13] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[12] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[12] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[11] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[11] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[10] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[10] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[9] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[9] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[8] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[8] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[7] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[7] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[6] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[6] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[5] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[5] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[4] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[4] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[3] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[3] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[2] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[2] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[1] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[1] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[0] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[0] = binary.BigEndian.Uint64(y_bytes[400:408])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:408])
	   yInt := new(big.Int).SetBytes(y_bytes[0:408])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [52]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 51")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)

	t[51], D = bits.Add64(t[51], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	t[50], C = bits.Add64(t[51], C, 0)
	t[51], _ = bits.Add64(0, D, C)

	for j := 1; j < 51; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		t[51], D = bits.Add64(t[51], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		t[50], C = bits.Add64(t[51], C, 0)
		t[51], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)

	var src []uint64
	if D != 0 && t[51] == 0 {
		src = t[:51]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[50])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[49])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[48])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[47])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[46])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[45])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[44])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[43])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[42])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[41])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[40])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[39])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[38])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[37])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[36])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[35])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[34])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[33])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[32])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[31])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[30])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[29])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[28])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[27])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[26])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[25])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[24])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[23])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[22])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[21])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[20])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[19])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[18])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[17])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[16])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[15])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[14])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[13])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[12])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[11])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[10])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[9])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[8])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[7])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[6])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[5])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[4])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[3])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[2])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[1])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[0])

	return nil
}

func MulMontNonUnrolled3328(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [52]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[51] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[51] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[50] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[50] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[49] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[49] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[48] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[48] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[47] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[47] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[46] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[46] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[45] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[45] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[44] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[44] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[43] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[43] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[42] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[42] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[41] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[41] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[40] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[40] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[39] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[39] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[38] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[38] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[37] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[37] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[36] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[36] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[35] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[35] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[34] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[34] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[33] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[33] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[32] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[32] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[31] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[31] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[30] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[30] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[29] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[29] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[28] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[28] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[27] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[27] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[26] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[26] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[25] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[25] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[24] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[24] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[23] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[23] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[22] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[22] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[21] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[21] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[20] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[20] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[19] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[19] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[18] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[18] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[17] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[17] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[16] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[16] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[15] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[15] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[14] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[14] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[13] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[13] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[12] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[12] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[11] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[11] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[10] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[10] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[9] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[9] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[8] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[8] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[7] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[7] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[6] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[6] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[5] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[5] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[4] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[4] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[3] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[3] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[2] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[2] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[1] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[1] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[0] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[0] = binary.BigEndian.Uint64(y_bytes[408:416])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:416])
	   yInt := new(big.Int).SetBytes(y_bytes[0:416])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [53]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 52")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)

	t[52], D = bits.Add64(t[52], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	t[51], C = bits.Add64(t[52], C, 0)
	t[52], _ = bits.Add64(0, D, C)

	for j := 1; j < 52; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		t[52], D = bits.Add64(t[52], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		t[51], C = bits.Add64(t[52], C, 0)
		t[52], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)

	var src []uint64
	if D != 0 && t[52] == 0 {
		src = t[:52]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[51])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[50])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[49])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[48])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[47])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[46])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[45])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[44])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[43])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[42])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[41])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[40])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[39])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[38])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[37])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[36])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[35])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[34])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[33])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[32])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[31])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[30])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[29])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[28])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[27])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[26])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[25])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[24])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[23])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[22])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[21])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[20])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[19])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[18])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[17])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[16])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[15])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[14])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[13])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[12])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[11])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[10])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[9])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[8])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[7])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[6])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[5])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[4])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[3])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[2])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[1])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[0])

	return nil
}

func MulMontNonUnrolled3392(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [53]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[52] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[52] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[51] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[51] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[50] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[50] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[49] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[49] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[48] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[48] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[47] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[47] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[46] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[46] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[45] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[45] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[44] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[44] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[43] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[43] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[42] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[42] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[41] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[41] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[40] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[40] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[39] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[39] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[38] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[38] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[37] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[37] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[36] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[36] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[35] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[35] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[34] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[34] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[33] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[33] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[32] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[32] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[31] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[31] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[30] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[30] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[29] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[29] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[28] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[28] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[27] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[27] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[26] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[26] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[25] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[25] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[24] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[24] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[23] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[23] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[22] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[22] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[21] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[21] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[20] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[20] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[19] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[19] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[18] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[18] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[17] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[17] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[16] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[16] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[15] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[15] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[14] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[14] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[13] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[13] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[12] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[12] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[11] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[11] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[10] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[10] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[9] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[9] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[8] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[8] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[7] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[7] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[6] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[6] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[5] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[5] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[4] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[4] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[3] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[3] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[2] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[2] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[1] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[1] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[0] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[0] = binary.BigEndian.Uint64(y_bytes[416:424])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:424])
	   yInt := new(big.Int).SetBytes(y_bytes[0:424])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [54]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 53")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)

	t[53], D = bits.Add64(t[53], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	t[52], C = bits.Add64(t[53], C, 0)
	t[53], _ = bits.Add64(0, D, C)

	for j := 1; j < 53; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		t[53], D = bits.Add64(t[53], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		t[52], C = bits.Add64(t[53], C, 0)
		t[53], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)

	var src []uint64
	if D != 0 && t[53] == 0 {
		src = t[:53]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[52])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[51])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[50])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[49])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[48])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[47])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[46])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[45])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[44])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[43])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[42])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[41])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[40])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[39])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[38])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[37])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[36])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[35])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[34])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[33])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[32])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[31])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[30])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[29])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[28])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[27])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[26])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[25])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[24])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[23])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[22])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[21])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[20])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[19])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[18])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[17])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[16])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[15])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[14])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[13])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[12])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[11])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[10])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[9])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[8])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[7])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[6])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[5])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[4])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[3])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[2])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[1])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[0])

	return nil
}

func MulMontNonUnrolled3456(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [54]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[53] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[53] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[52] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[52] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[51] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[51] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[50] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[50] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[49] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[49] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[48] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[48] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[47] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[47] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[46] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[46] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[45] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[45] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[44] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[44] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[43] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[43] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[42] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[42] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[41] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[41] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[40] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[40] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[39] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[39] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[38] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[38] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[37] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[37] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[36] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[36] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[35] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[35] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[34] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[34] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[33] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[33] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[32] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[32] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[31] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[31] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[30] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[30] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[29] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[29] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[28] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[28] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[27] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[27] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[26] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[26] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[25] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[25] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[24] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[24] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[23] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[23] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[22] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[22] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[21] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[21] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[20] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[20] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[19] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[19] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[18] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[18] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[17] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[17] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[16] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[16] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[15] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[15] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[14] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[14] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[13] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[13] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[12] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[12] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[11] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[11] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[10] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[10] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[9] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[9] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[8] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[8] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[7] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[7] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[6] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[6] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[5] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[5] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[4] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[4] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[3] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[3] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[2] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[2] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[1] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[1] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[0] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[0] = binary.BigEndian.Uint64(y_bytes[424:432])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:432])
	   yInt := new(big.Int).SetBytes(y_bytes[0:432])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [55]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 54")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)

	t[54], D = bits.Add64(t[54], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	t[53], C = bits.Add64(t[54], C, 0)
	t[54], _ = bits.Add64(0, D, C)

	for j := 1; j < 54; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		t[54], D = bits.Add64(t[54], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		t[53], C = bits.Add64(t[54], C, 0)
		t[54], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)

	var src []uint64
	if D != 0 && t[54] == 0 {
		src = t[:54]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[53])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[52])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[51])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[50])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[49])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[48])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[47])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[46])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[45])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[44])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[43])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[42])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[41])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[40])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[39])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[38])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[37])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[36])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[35])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[34])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[33])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[32])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[31])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[30])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[29])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[28])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[27])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[26])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[25])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[24])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[23])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[22])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[21])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[20])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[19])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[18])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[17])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[16])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[15])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[14])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[13])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[12])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[11])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[10])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[9])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[8])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[7])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[6])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[5])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[4])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[3])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[2])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[1])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[0])

	return nil
}

func MulMontNonUnrolled3520(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [55]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[54] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[54] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[53] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[53] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[52] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[52] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[51] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[51] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[50] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[50] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[49] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[49] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[48] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[48] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[47] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[47] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[46] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[46] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[45] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[45] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[44] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[44] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[43] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[43] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[42] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[42] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[41] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[41] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[40] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[40] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[39] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[39] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[38] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[38] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[37] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[37] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[36] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[36] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[35] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[35] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[34] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[34] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[33] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[33] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[32] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[32] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[31] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[31] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[30] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[30] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[29] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[29] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[28] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[28] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[27] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[27] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[26] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[26] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[25] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[25] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[24] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[24] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[23] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[23] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[22] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[22] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[21] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[21] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[20] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[20] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[19] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[19] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[18] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[18] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[17] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[17] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[16] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[16] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[15] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[15] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[14] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[14] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[13] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[13] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[12] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[12] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[11] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[11] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[10] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[10] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[9] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[9] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[8] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[8] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[7] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[7] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[6] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[6] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[5] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[5] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[4] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[4] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[3] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[3] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[2] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[2] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[1] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[1] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[0] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[0] = binary.BigEndian.Uint64(y_bytes[432:440])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:440])
	   yInt := new(big.Int).SetBytes(y_bytes[0:440])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [56]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 55")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)

	t[55], D = bits.Add64(t[55], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	t[54], C = bits.Add64(t[55], C, 0)
	t[55], _ = bits.Add64(0, D, C)

	for j := 1; j < 55; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		t[55], D = bits.Add64(t[55], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		t[54], C = bits.Add64(t[55], C, 0)
		t[55], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)

	var src []uint64
	if D != 0 && t[55] == 0 {
		src = t[:55]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[54])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[53])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[52])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[51])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[50])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[49])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[48])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[47])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[46])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[45])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[44])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[43])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[42])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[41])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[40])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[39])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[38])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[37])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[36])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[35])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[34])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[33])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[32])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[31])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[30])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[29])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[28])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[27])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[26])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[25])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[24])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[23])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[22])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[21])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[20])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[19])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[18])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[17])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[16])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[15])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[14])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[13])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[12])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[11])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[10])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[9])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[8])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[7])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[6])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[5])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[4])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[3])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[2])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[1])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[0])

	return nil
}

func MulMontNonUnrolled3584(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [56]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[55] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[55] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[54] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[54] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[53] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[53] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[52] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[52] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[51] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[51] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[50] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[50] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[49] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[49] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[48] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[48] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[47] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[47] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[46] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[46] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[45] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[45] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[44] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[44] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[43] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[43] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[42] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[42] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[41] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[41] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[40] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[40] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[39] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[39] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[38] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[38] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[37] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[37] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[36] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[36] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[35] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[35] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[34] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[34] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[33] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[33] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[32] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[32] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[31] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[31] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[30] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[30] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[29] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[29] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[28] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[28] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[27] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[27] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[26] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[26] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[25] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[25] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[24] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[24] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[23] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[23] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[22] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[22] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[21] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[21] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[20] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[20] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[19] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[19] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[18] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[18] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[17] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[17] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[16] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[16] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[15] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[15] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[14] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[14] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[13] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[13] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[12] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[12] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[11] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[11] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[10] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[10] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[9] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[9] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[8] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[8] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[7] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[7] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[6] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[6] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[5] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[5] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[4] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[4] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[3] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[3] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[2] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[2] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[1] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[1] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[0] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[0] = binary.BigEndian.Uint64(y_bytes[440:448])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:448])
	   yInt := new(big.Int).SetBytes(y_bytes[0:448])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [57]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 56")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)

	t[56], D = bits.Add64(t[56], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	t[55], C = bits.Add64(t[56], C, 0)
	t[56], _ = bits.Add64(0, D, C)

	for j := 1; j < 56; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		t[56], D = bits.Add64(t[56], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		t[55], C = bits.Add64(t[56], C, 0)
		t[56], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)

	var src []uint64
	if D != 0 && t[56] == 0 {
		src = t[:56]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[55])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[54])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[53])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[52])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[51])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[50])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[49])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[48])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[47])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[46])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[45])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[44])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[43])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[42])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[41])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[40])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[39])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[38])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[37])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[36])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[35])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[34])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[33])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[32])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[31])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[30])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[29])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[28])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[27])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[26])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[25])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[24])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[23])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[22])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[21])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[20])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[19])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[18])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[17])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[16])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[15])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[14])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[13])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[12])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[11])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[10])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[9])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[8])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[7])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[6])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[5])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[4])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[3])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[2])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[1])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[0])

	return nil
}

func MulMontNonUnrolled3648(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [57]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[56] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[56] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[55] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[55] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[54] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[54] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[53] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[53] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[52] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[52] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[51] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[51] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[50] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[50] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[49] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[49] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[48] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[48] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[47] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[47] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[46] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[46] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[45] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[45] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[44] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[44] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[43] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[43] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[42] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[42] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[41] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[41] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[40] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[40] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[39] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[39] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[38] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[38] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[37] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[37] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[36] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[36] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[35] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[35] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[34] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[34] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[33] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[33] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[32] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[32] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[31] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[31] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[30] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[30] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[29] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[29] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[28] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[28] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[27] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[27] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[26] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[26] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[25] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[25] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[24] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[24] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[23] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[23] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[22] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[22] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[21] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[21] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[20] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[20] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[19] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[19] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[18] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[18] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[17] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[17] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[16] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[16] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[15] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[15] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[14] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[14] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[13] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[13] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[12] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[12] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[11] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[11] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[10] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[10] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[9] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[9] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[8] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[8] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[7] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[7] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[6] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[6] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[5] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[5] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[4] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[4] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[3] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[3] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[2] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[2] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[1] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[1] = binary.BigEndian.Uint64(y_bytes[440:448])
	x[0] = binary.BigEndian.Uint64(x_bytes[448:456])
	y[0] = binary.BigEndian.Uint64(y_bytes[448:456])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:456])
	   yInt := new(big.Int).SetBytes(y_bytes[0:456])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [58]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 57")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC1 = bits.Sub64(mod[56], x[56], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)
	_, gteC2 = bits.Sub64(mod[56], y[56], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)
	C, t[56] = madd1(x[0], y[56], C)

	t[57], D = bits.Add64(t[57], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	C, t[55] = madd2(m, mod[56], t[56], C)
	t[56], C = bits.Add64(t[57], C, 0)
	t[57], _ = bits.Add64(0, D, C)

	for j := 1; j < 57; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		C, t[56] = madd2(x[j], y[56], t[56], C)
		t[57], D = bits.Add64(t[57], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		C, t[55] = madd2(m, mod[56], t[56], C)
		t[56], C = bits.Add64(t[57], C, 0)
		t[57], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)
	z[56], D = bits.Sub64(t[56], mod[56], D)

	var src []uint64
	if D != 0 && t[57] == 0 {
		src = t[:57]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[56])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[55])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[54])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[53])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[52])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[51])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[50])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[49])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[48])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[47])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[46])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[45])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[44])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[43])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[42])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[41])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[40])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[39])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[38])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[37])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[36])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[35])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[34])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[33])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[32])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[31])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[30])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[29])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[28])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[27])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[26])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[25])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[24])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[23])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[22])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[21])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[20])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[19])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[18])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[17])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[16])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[15])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[14])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[13])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[12])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[11])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[10])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[9])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[8])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[7])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[6])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[5])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[4])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[3])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[2])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[1])
	binary.BigEndian.PutUint64(z_bytes[448:456], src[0])

	return nil
}

func MulMontNonUnrolled3712(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [58]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[57] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[57] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[56] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[56] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[55] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[55] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[54] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[54] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[53] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[53] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[52] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[52] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[51] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[51] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[50] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[50] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[49] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[49] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[48] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[48] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[47] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[47] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[46] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[46] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[45] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[45] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[44] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[44] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[43] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[43] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[42] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[42] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[41] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[41] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[40] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[40] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[39] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[39] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[38] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[38] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[37] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[37] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[36] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[36] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[35] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[35] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[34] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[34] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[33] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[33] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[32] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[32] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[31] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[31] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[30] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[30] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[29] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[29] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[28] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[28] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[27] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[27] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[26] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[26] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[25] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[25] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[24] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[24] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[23] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[23] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[22] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[22] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[21] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[21] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[20] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[20] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[19] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[19] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[18] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[18] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[17] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[17] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[16] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[16] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[15] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[15] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[14] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[14] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[13] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[13] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[12] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[12] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[11] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[11] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[10] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[10] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[9] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[9] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[8] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[8] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[7] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[7] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[6] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[6] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[5] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[5] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[4] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[4] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[3] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[3] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[2] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[2] = binary.BigEndian.Uint64(y_bytes[440:448])
	x[1] = binary.BigEndian.Uint64(x_bytes[448:456])
	y[1] = binary.BigEndian.Uint64(y_bytes[448:456])
	x[0] = binary.BigEndian.Uint64(x_bytes[456:464])
	y[0] = binary.BigEndian.Uint64(y_bytes[456:464])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:464])
	   yInt := new(big.Int).SetBytes(y_bytes[0:464])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [59]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 58")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC1 = bits.Sub64(mod[56], x[56], gteC1)
	_, gteC1 = bits.Sub64(mod[57], x[57], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)
	_, gteC2 = bits.Sub64(mod[56], y[56], gteC2)
	_, gteC2 = bits.Sub64(mod[57], y[57], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)
	C, t[56] = madd1(x[0], y[56], C)
	C, t[57] = madd1(x[0], y[57], C)

	t[58], D = bits.Add64(t[58], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	C, t[55] = madd2(m, mod[56], t[56], C)
	C, t[56] = madd2(m, mod[57], t[57], C)
	t[57], C = bits.Add64(t[58], C, 0)
	t[58], _ = bits.Add64(0, D, C)

	for j := 1; j < 58; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		C, t[56] = madd2(x[j], y[56], t[56], C)
		C, t[57] = madd2(x[j], y[57], t[57], C)
		t[58], D = bits.Add64(t[58], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		C, t[55] = madd2(m, mod[56], t[56], C)
		C, t[56] = madd2(m, mod[57], t[57], C)
		t[57], C = bits.Add64(t[58], C, 0)
		t[58], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)
	z[56], D = bits.Sub64(t[56], mod[56], D)
	z[57], D = bits.Sub64(t[57], mod[57], D)

	var src []uint64
	if D != 0 && t[58] == 0 {
		src = t[:58]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[57])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[56])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[55])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[54])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[53])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[52])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[51])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[50])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[49])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[48])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[47])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[46])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[45])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[44])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[43])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[42])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[41])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[40])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[39])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[38])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[37])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[36])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[35])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[34])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[33])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[32])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[31])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[30])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[29])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[28])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[27])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[26])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[25])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[24])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[23])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[22])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[21])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[20])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[19])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[18])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[17])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[16])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[15])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[14])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[13])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[12])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[11])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[10])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[9])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[8])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[7])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[6])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[5])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[4])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[3])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[2])
	binary.BigEndian.PutUint64(z_bytes[448:456], src[1])
	binary.BigEndian.PutUint64(z_bytes[456:464], src[0])

	return nil
}

func MulMontNonUnrolled3776(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [59]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[58] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[58] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[57] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[57] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[56] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[56] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[55] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[55] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[54] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[54] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[53] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[53] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[52] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[52] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[51] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[51] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[50] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[50] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[49] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[49] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[48] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[48] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[47] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[47] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[46] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[46] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[45] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[45] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[44] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[44] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[43] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[43] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[42] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[42] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[41] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[41] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[40] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[40] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[39] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[39] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[38] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[38] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[37] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[37] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[36] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[36] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[35] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[35] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[34] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[34] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[33] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[33] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[32] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[32] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[31] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[31] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[30] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[30] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[29] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[29] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[28] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[28] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[27] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[27] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[26] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[26] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[25] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[25] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[24] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[24] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[23] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[23] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[22] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[22] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[21] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[21] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[20] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[20] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[19] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[19] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[18] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[18] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[17] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[17] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[16] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[16] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[15] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[15] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[14] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[14] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[13] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[13] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[12] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[12] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[11] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[11] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[10] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[10] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[9] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[9] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[8] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[8] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[7] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[7] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[6] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[6] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[5] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[5] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[4] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[4] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[3] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[3] = binary.BigEndian.Uint64(y_bytes[440:448])
	x[2] = binary.BigEndian.Uint64(x_bytes[448:456])
	y[2] = binary.BigEndian.Uint64(y_bytes[448:456])
	x[1] = binary.BigEndian.Uint64(x_bytes[456:464])
	y[1] = binary.BigEndian.Uint64(y_bytes[456:464])
	x[0] = binary.BigEndian.Uint64(x_bytes[464:472])
	y[0] = binary.BigEndian.Uint64(y_bytes[464:472])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:472])
	   yInt := new(big.Int).SetBytes(y_bytes[0:472])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [60]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 59")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC1 = bits.Sub64(mod[56], x[56], gteC1)
	_, gteC1 = bits.Sub64(mod[57], x[57], gteC1)
	_, gteC1 = bits.Sub64(mod[58], x[58], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)
	_, gteC2 = bits.Sub64(mod[56], y[56], gteC2)
	_, gteC2 = bits.Sub64(mod[57], y[57], gteC2)
	_, gteC2 = bits.Sub64(mod[58], y[58], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)
	C, t[56] = madd1(x[0], y[56], C)
	C, t[57] = madd1(x[0], y[57], C)
	C, t[58] = madd1(x[0], y[58], C)

	t[59], D = bits.Add64(t[59], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	C, t[55] = madd2(m, mod[56], t[56], C)
	C, t[56] = madd2(m, mod[57], t[57], C)
	C, t[57] = madd2(m, mod[58], t[58], C)
	t[58], C = bits.Add64(t[59], C, 0)
	t[59], _ = bits.Add64(0, D, C)

	for j := 1; j < 59; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		C, t[56] = madd2(x[j], y[56], t[56], C)
		C, t[57] = madd2(x[j], y[57], t[57], C)
		C, t[58] = madd2(x[j], y[58], t[58], C)
		t[59], D = bits.Add64(t[59], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		C, t[55] = madd2(m, mod[56], t[56], C)
		C, t[56] = madd2(m, mod[57], t[57], C)
		C, t[57] = madd2(m, mod[58], t[58], C)
		t[58], C = bits.Add64(t[59], C, 0)
		t[59], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)
	z[56], D = bits.Sub64(t[56], mod[56], D)
	z[57], D = bits.Sub64(t[57], mod[57], D)
	z[58], D = bits.Sub64(t[58], mod[58], D)

	var src []uint64
	if D != 0 && t[59] == 0 {
		src = t[:59]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[58])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[57])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[56])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[55])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[54])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[53])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[52])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[51])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[50])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[49])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[48])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[47])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[46])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[45])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[44])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[43])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[42])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[41])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[40])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[39])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[38])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[37])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[36])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[35])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[34])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[33])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[32])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[31])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[30])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[29])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[28])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[27])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[26])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[25])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[24])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[23])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[22])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[21])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[20])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[19])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[18])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[17])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[16])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[15])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[14])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[13])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[12])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[11])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[10])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[9])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[8])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[7])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[6])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[5])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[4])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[3])
	binary.BigEndian.PutUint64(z_bytes[448:456], src[2])
	binary.BigEndian.PutUint64(z_bytes[456:464], src[1])
	binary.BigEndian.PutUint64(z_bytes[464:472], src[0])

	return nil
}

func MulMontNonUnrolled3840(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [60]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[59] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[59] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[58] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[58] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[57] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[57] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[56] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[56] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[55] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[55] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[54] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[54] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[53] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[53] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[52] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[52] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[51] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[51] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[50] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[50] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[49] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[49] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[48] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[48] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[47] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[47] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[46] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[46] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[45] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[45] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[44] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[44] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[43] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[43] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[42] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[42] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[41] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[41] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[40] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[40] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[39] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[39] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[38] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[38] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[37] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[37] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[36] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[36] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[35] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[35] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[34] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[34] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[33] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[33] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[32] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[32] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[31] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[31] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[30] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[30] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[29] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[29] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[28] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[28] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[27] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[27] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[26] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[26] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[25] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[25] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[24] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[24] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[23] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[23] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[22] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[22] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[21] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[21] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[20] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[20] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[19] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[19] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[18] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[18] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[17] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[17] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[16] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[16] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[15] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[15] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[14] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[14] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[13] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[13] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[12] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[12] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[11] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[11] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[10] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[10] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[9] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[9] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[8] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[8] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[7] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[7] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[6] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[6] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[5] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[5] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[4] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[4] = binary.BigEndian.Uint64(y_bytes[440:448])
	x[3] = binary.BigEndian.Uint64(x_bytes[448:456])
	y[3] = binary.BigEndian.Uint64(y_bytes[448:456])
	x[2] = binary.BigEndian.Uint64(x_bytes[456:464])
	y[2] = binary.BigEndian.Uint64(y_bytes[456:464])
	x[1] = binary.BigEndian.Uint64(x_bytes[464:472])
	y[1] = binary.BigEndian.Uint64(y_bytes[464:472])
	x[0] = binary.BigEndian.Uint64(x_bytes[472:480])
	y[0] = binary.BigEndian.Uint64(y_bytes[472:480])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:480])
	   yInt := new(big.Int).SetBytes(y_bytes[0:480])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [61]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 60")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC1 = bits.Sub64(mod[56], x[56], gteC1)
	_, gteC1 = bits.Sub64(mod[57], x[57], gteC1)
	_, gteC1 = bits.Sub64(mod[58], x[58], gteC1)
	_, gteC1 = bits.Sub64(mod[59], x[59], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)
	_, gteC2 = bits.Sub64(mod[56], y[56], gteC2)
	_, gteC2 = bits.Sub64(mod[57], y[57], gteC2)
	_, gteC2 = bits.Sub64(mod[58], y[58], gteC2)
	_, gteC2 = bits.Sub64(mod[59], y[59], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)
	C, t[56] = madd1(x[0], y[56], C)
	C, t[57] = madd1(x[0], y[57], C)
	C, t[58] = madd1(x[0], y[58], C)
	C, t[59] = madd1(x[0], y[59], C)

	t[60], D = bits.Add64(t[60], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	C, t[55] = madd2(m, mod[56], t[56], C)
	C, t[56] = madd2(m, mod[57], t[57], C)
	C, t[57] = madd2(m, mod[58], t[58], C)
	C, t[58] = madd2(m, mod[59], t[59], C)
	t[59], C = bits.Add64(t[60], C, 0)
	t[60], _ = bits.Add64(0, D, C)

	for j := 1; j < 60; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		C, t[56] = madd2(x[j], y[56], t[56], C)
		C, t[57] = madd2(x[j], y[57], t[57], C)
		C, t[58] = madd2(x[j], y[58], t[58], C)
		C, t[59] = madd2(x[j], y[59], t[59], C)
		t[60], D = bits.Add64(t[60], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		C, t[55] = madd2(m, mod[56], t[56], C)
		C, t[56] = madd2(m, mod[57], t[57], C)
		C, t[57] = madd2(m, mod[58], t[58], C)
		C, t[58] = madd2(m, mod[59], t[59], C)
		t[59], C = bits.Add64(t[60], C, 0)
		t[60], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)
	z[56], D = bits.Sub64(t[56], mod[56], D)
	z[57], D = bits.Sub64(t[57], mod[57], D)
	z[58], D = bits.Sub64(t[58], mod[58], D)
	z[59], D = bits.Sub64(t[59], mod[59], D)

	var src []uint64
	if D != 0 && t[60] == 0 {
		src = t[:60]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[59])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[58])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[57])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[56])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[55])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[54])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[53])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[52])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[51])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[50])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[49])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[48])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[47])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[46])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[45])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[44])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[43])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[42])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[41])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[40])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[39])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[38])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[37])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[36])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[35])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[34])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[33])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[32])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[31])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[30])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[29])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[28])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[27])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[26])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[25])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[24])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[23])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[22])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[21])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[20])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[19])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[18])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[17])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[16])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[15])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[14])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[13])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[12])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[11])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[10])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[9])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[8])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[7])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[6])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[5])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[4])
	binary.BigEndian.PutUint64(z_bytes[448:456], src[3])
	binary.BigEndian.PutUint64(z_bytes[456:464], src[2])
	binary.BigEndian.PutUint64(z_bytes[464:472], src[1])
	binary.BigEndian.PutUint64(z_bytes[472:480], src[0])

	return nil
}

func MulMontNonUnrolled3904(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [61]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[60] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[60] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[59] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[59] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[58] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[58] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[57] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[57] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[56] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[56] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[55] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[55] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[54] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[54] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[53] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[53] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[52] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[52] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[51] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[51] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[50] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[50] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[49] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[49] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[48] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[48] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[47] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[47] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[46] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[46] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[45] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[45] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[44] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[44] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[43] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[43] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[42] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[42] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[41] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[41] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[40] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[40] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[39] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[39] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[38] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[38] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[37] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[37] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[36] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[36] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[35] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[35] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[34] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[34] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[33] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[33] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[32] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[32] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[31] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[31] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[30] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[30] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[29] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[29] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[28] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[28] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[27] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[27] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[26] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[26] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[25] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[25] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[24] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[24] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[23] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[23] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[22] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[22] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[21] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[21] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[20] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[20] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[19] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[19] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[18] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[18] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[17] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[17] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[16] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[16] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[15] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[15] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[14] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[14] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[13] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[13] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[12] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[12] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[11] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[11] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[10] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[10] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[9] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[9] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[8] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[8] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[7] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[7] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[6] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[6] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[5] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[5] = binary.BigEndian.Uint64(y_bytes[440:448])
	x[4] = binary.BigEndian.Uint64(x_bytes[448:456])
	y[4] = binary.BigEndian.Uint64(y_bytes[448:456])
	x[3] = binary.BigEndian.Uint64(x_bytes[456:464])
	y[3] = binary.BigEndian.Uint64(y_bytes[456:464])
	x[2] = binary.BigEndian.Uint64(x_bytes[464:472])
	y[2] = binary.BigEndian.Uint64(y_bytes[464:472])
	x[1] = binary.BigEndian.Uint64(x_bytes[472:480])
	y[1] = binary.BigEndian.Uint64(y_bytes[472:480])
	x[0] = binary.BigEndian.Uint64(x_bytes[480:488])
	y[0] = binary.BigEndian.Uint64(y_bytes[480:488])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:488])
	   yInt := new(big.Int).SetBytes(y_bytes[0:488])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [62]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 61")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC1 = bits.Sub64(mod[56], x[56], gteC1)
	_, gteC1 = bits.Sub64(mod[57], x[57], gteC1)
	_, gteC1 = bits.Sub64(mod[58], x[58], gteC1)
	_, gteC1 = bits.Sub64(mod[59], x[59], gteC1)
	_, gteC1 = bits.Sub64(mod[60], x[60], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)
	_, gteC2 = bits.Sub64(mod[56], y[56], gteC2)
	_, gteC2 = bits.Sub64(mod[57], y[57], gteC2)
	_, gteC2 = bits.Sub64(mod[58], y[58], gteC2)
	_, gteC2 = bits.Sub64(mod[59], y[59], gteC2)
	_, gteC2 = bits.Sub64(mod[60], y[60], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)
	C, t[56] = madd1(x[0], y[56], C)
	C, t[57] = madd1(x[0], y[57], C)
	C, t[58] = madd1(x[0], y[58], C)
	C, t[59] = madd1(x[0], y[59], C)
	C, t[60] = madd1(x[0], y[60], C)

	t[61], D = bits.Add64(t[61], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	C, t[55] = madd2(m, mod[56], t[56], C)
	C, t[56] = madd2(m, mod[57], t[57], C)
	C, t[57] = madd2(m, mod[58], t[58], C)
	C, t[58] = madd2(m, mod[59], t[59], C)
	C, t[59] = madd2(m, mod[60], t[60], C)
	t[60], C = bits.Add64(t[61], C, 0)
	t[61], _ = bits.Add64(0, D, C)

	for j := 1; j < 61; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		C, t[56] = madd2(x[j], y[56], t[56], C)
		C, t[57] = madd2(x[j], y[57], t[57], C)
		C, t[58] = madd2(x[j], y[58], t[58], C)
		C, t[59] = madd2(x[j], y[59], t[59], C)
		C, t[60] = madd2(x[j], y[60], t[60], C)
		t[61], D = bits.Add64(t[61], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		C, t[55] = madd2(m, mod[56], t[56], C)
		C, t[56] = madd2(m, mod[57], t[57], C)
		C, t[57] = madd2(m, mod[58], t[58], C)
		C, t[58] = madd2(m, mod[59], t[59], C)
		C, t[59] = madd2(m, mod[60], t[60], C)
		t[60], C = bits.Add64(t[61], C, 0)
		t[61], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)
	z[56], D = bits.Sub64(t[56], mod[56], D)
	z[57], D = bits.Sub64(t[57], mod[57], D)
	z[58], D = bits.Sub64(t[58], mod[58], D)
	z[59], D = bits.Sub64(t[59], mod[59], D)
	z[60], D = bits.Sub64(t[60], mod[60], D)

	var src []uint64
	if D != 0 && t[61] == 0 {
		src = t[:61]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[60])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[59])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[58])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[57])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[56])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[55])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[54])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[53])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[52])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[51])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[50])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[49])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[48])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[47])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[46])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[45])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[44])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[43])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[42])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[41])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[40])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[39])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[38])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[37])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[36])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[35])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[34])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[33])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[32])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[31])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[30])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[29])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[28])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[27])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[26])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[25])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[24])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[23])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[22])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[21])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[20])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[19])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[18])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[17])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[16])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[15])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[14])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[13])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[12])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[11])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[10])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[9])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[8])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[7])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[6])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[5])
	binary.BigEndian.PutUint64(z_bytes[448:456], src[4])
	binary.BigEndian.PutUint64(z_bytes[456:464], src[3])
	binary.BigEndian.PutUint64(z_bytes[464:472], src[2])
	binary.BigEndian.PutUint64(z_bytes[472:480], src[1])
	binary.BigEndian.PutUint64(z_bytes[480:488], src[0])

	return nil
}

func MulMontNonUnrolled3968(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [62]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[61] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[61] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[60] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[60] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[59] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[59] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[58] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[58] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[57] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[57] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[56] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[56] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[55] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[55] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[54] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[54] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[53] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[53] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[52] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[52] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[51] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[51] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[50] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[50] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[49] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[49] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[48] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[48] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[47] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[47] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[46] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[46] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[45] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[45] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[44] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[44] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[43] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[43] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[42] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[42] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[41] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[41] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[40] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[40] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[39] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[39] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[38] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[38] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[37] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[37] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[36] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[36] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[35] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[35] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[34] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[34] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[33] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[33] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[32] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[32] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[31] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[31] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[30] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[30] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[29] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[29] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[28] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[28] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[27] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[27] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[26] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[26] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[25] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[25] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[24] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[24] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[23] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[23] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[22] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[22] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[21] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[21] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[20] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[20] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[19] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[19] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[18] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[18] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[17] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[17] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[16] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[16] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[15] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[15] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[14] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[14] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[13] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[13] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[12] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[12] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[11] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[11] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[10] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[10] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[9] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[9] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[8] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[8] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[7] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[7] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[6] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[6] = binary.BigEndian.Uint64(y_bytes[440:448])
	x[5] = binary.BigEndian.Uint64(x_bytes[448:456])
	y[5] = binary.BigEndian.Uint64(y_bytes[448:456])
	x[4] = binary.BigEndian.Uint64(x_bytes[456:464])
	y[4] = binary.BigEndian.Uint64(y_bytes[456:464])
	x[3] = binary.BigEndian.Uint64(x_bytes[464:472])
	y[3] = binary.BigEndian.Uint64(y_bytes[464:472])
	x[2] = binary.BigEndian.Uint64(x_bytes[472:480])
	y[2] = binary.BigEndian.Uint64(y_bytes[472:480])
	x[1] = binary.BigEndian.Uint64(x_bytes[480:488])
	y[1] = binary.BigEndian.Uint64(y_bytes[480:488])
	x[0] = binary.BigEndian.Uint64(x_bytes[488:496])
	y[0] = binary.BigEndian.Uint64(y_bytes[488:496])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:496])
	   yInt := new(big.Int).SetBytes(y_bytes[0:496])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [63]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 62")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC1 = bits.Sub64(mod[56], x[56], gteC1)
	_, gteC1 = bits.Sub64(mod[57], x[57], gteC1)
	_, gteC1 = bits.Sub64(mod[58], x[58], gteC1)
	_, gteC1 = bits.Sub64(mod[59], x[59], gteC1)
	_, gteC1 = bits.Sub64(mod[60], x[60], gteC1)
	_, gteC1 = bits.Sub64(mod[61], x[61], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)
	_, gteC2 = bits.Sub64(mod[56], y[56], gteC2)
	_, gteC2 = bits.Sub64(mod[57], y[57], gteC2)
	_, gteC2 = bits.Sub64(mod[58], y[58], gteC2)
	_, gteC2 = bits.Sub64(mod[59], y[59], gteC2)
	_, gteC2 = bits.Sub64(mod[60], y[60], gteC2)
	_, gteC2 = bits.Sub64(mod[61], y[61], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)
	C, t[56] = madd1(x[0], y[56], C)
	C, t[57] = madd1(x[0], y[57], C)
	C, t[58] = madd1(x[0], y[58], C)
	C, t[59] = madd1(x[0], y[59], C)
	C, t[60] = madd1(x[0], y[60], C)
	C, t[61] = madd1(x[0], y[61], C)

	t[62], D = bits.Add64(t[62], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	C, t[55] = madd2(m, mod[56], t[56], C)
	C, t[56] = madd2(m, mod[57], t[57], C)
	C, t[57] = madd2(m, mod[58], t[58], C)
	C, t[58] = madd2(m, mod[59], t[59], C)
	C, t[59] = madd2(m, mod[60], t[60], C)
	C, t[60] = madd2(m, mod[61], t[61], C)
	t[61], C = bits.Add64(t[62], C, 0)
	t[62], _ = bits.Add64(0, D, C)

	for j := 1; j < 62; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		C, t[56] = madd2(x[j], y[56], t[56], C)
		C, t[57] = madd2(x[j], y[57], t[57], C)
		C, t[58] = madd2(x[j], y[58], t[58], C)
		C, t[59] = madd2(x[j], y[59], t[59], C)
		C, t[60] = madd2(x[j], y[60], t[60], C)
		C, t[61] = madd2(x[j], y[61], t[61], C)
		t[62], D = bits.Add64(t[62], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		C, t[55] = madd2(m, mod[56], t[56], C)
		C, t[56] = madd2(m, mod[57], t[57], C)
		C, t[57] = madd2(m, mod[58], t[58], C)
		C, t[58] = madd2(m, mod[59], t[59], C)
		C, t[59] = madd2(m, mod[60], t[60], C)
		C, t[60] = madd2(m, mod[61], t[61], C)
		t[61], C = bits.Add64(t[62], C, 0)
		t[62], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)
	z[56], D = bits.Sub64(t[56], mod[56], D)
	z[57], D = bits.Sub64(t[57], mod[57], D)
	z[58], D = bits.Sub64(t[58], mod[58], D)
	z[59], D = bits.Sub64(t[59], mod[59], D)
	z[60], D = bits.Sub64(t[60], mod[60], D)
	z[61], D = bits.Sub64(t[61], mod[61], D)

	var src []uint64
	if D != 0 && t[62] == 0 {
		src = t[:62]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[61])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[60])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[59])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[58])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[57])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[56])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[55])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[54])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[53])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[52])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[51])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[50])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[49])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[48])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[47])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[46])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[45])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[44])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[43])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[42])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[41])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[40])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[39])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[38])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[37])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[36])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[35])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[34])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[33])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[32])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[31])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[30])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[29])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[28])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[27])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[26])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[25])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[24])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[23])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[22])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[21])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[20])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[19])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[18])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[17])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[16])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[15])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[14])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[13])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[12])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[11])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[10])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[9])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[8])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[7])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[6])
	binary.BigEndian.PutUint64(z_bytes[448:456], src[5])
	binary.BigEndian.PutUint64(z_bytes[456:464], src[4])
	binary.BigEndian.PutUint64(z_bytes[464:472], src[3])
	binary.BigEndian.PutUint64(z_bytes[472:480], src[2])
	binary.BigEndian.PutUint64(z_bytes[480:488], src[1])
	binary.BigEndian.PutUint64(z_bytes[488:496], src[0])

	return nil
}

func MulMontNonUnrolled4032(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [63]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[62] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[62] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[61] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[61] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[60] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[60] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[59] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[59] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[58] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[58] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[57] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[57] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[56] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[56] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[55] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[55] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[54] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[54] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[53] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[53] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[52] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[52] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[51] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[51] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[50] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[50] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[49] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[49] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[48] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[48] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[47] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[47] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[46] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[46] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[45] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[45] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[44] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[44] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[43] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[43] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[42] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[42] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[41] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[41] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[40] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[40] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[39] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[39] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[38] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[38] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[37] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[37] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[36] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[36] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[35] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[35] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[34] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[34] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[33] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[33] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[32] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[32] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[31] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[31] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[30] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[30] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[29] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[29] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[28] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[28] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[27] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[27] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[26] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[26] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[25] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[25] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[24] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[24] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[23] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[23] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[22] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[22] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[21] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[21] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[20] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[20] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[19] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[19] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[18] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[18] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[17] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[17] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[16] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[16] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[15] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[15] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[14] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[14] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[13] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[13] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[12] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[12] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[11] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[11] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[10] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[10] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[9] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[9] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[8] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[8] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[7] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[7] = binary.BigEndian.Uint64(y_bytes[440:448])
	x[6] = binary.BigEndian.Uint64(x_bytes[448:456])
	y[6] = binary.BigEndian.Uint64(y_bytes[448:456])
	x[5] = binary.BigEndian.Uint64(x_bytes[456:464])
	y[5] = binary.BigEndian.Uint64(y_bytes[456:464])
	x[4] = binary.BigEndian.Uint64(x_bytes[464:472])
	y[4] = binary.BigEndian.Uint64(y_bytes[464:472])
	x[3] = binary.BigEndian.Uint64(x_bytes[472:480])
	y[3] = binary.BigEndian.Uint64(y_bytes[472:480])
	x[2] = binary.BigEndian.Uint64(x_bytes[480:488])
	y[2] = binary.BigEndian.Uint64(y_bytes[480:488])
	x[1] = binary.BigEndian.Uint64(x_bytes[488:496])
	y[1] = binary.BigEndian.Uint64(y_bytes[488:496])
	x[0] = binary.BigEndian.Uint64(x_bytes[496:504])
	y[0] = binary.BigEndian.Uint64(y_bytes[496:504])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:504])
	   yInt := new(big.Int).SetBytes(y_bytes[0:504])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [64]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 63")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC1 = bits.Sub64(mod[56], x[56], gteC1)
	_, gteC1 = bits.Sub64(mod[57], x[57], gteC1)
	_, gteC1 = bits.Sub64(mod[58], x[58], gteC1)
	_, gteC1 = bits.Sub64(mod[59], x[59], gteC1)
	_, gteC1 = bits.Sub64(mod[60], x[60], gteC1)
	_, gteC1 = bits.Sub64(mod[61], x[61], gteC1)
	_, gteC1 = bits.Sub64(mod[62], x[62], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)
	_, gteC2 = bits.Sub64(mod[56], y[56], gteC2)
	_, gteC2 = bits.Sub64(mod[57], y[57], gteC2)
	_, gteC2 = bits.Sub64(mod[58], y[58], gteC2)
	_, gteC2 = bits.Sub64(mod[59], y[59], gteC2)
	_, gteC2 = bits.Sub64(mod[60], y[60], gteC2)
	_, gteC2 = bits.Sub64(mod[61], y[61], gteC2)
	_, gteC2 = bits.Sub64(mod[62], y[62], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)
	C, t[56] = madd1(x[0], y[56], C)
	C, t[57] = madd1(x[0], y[57], C)
	C, t[58] = madd1(x[0], y[58], C)
	C, t[59] = madd1(x[0], y[59], C)
	C, t[60] = madd1(x[0], y[60], C)
	C, t[61] = madd1(x[0], y[61], C)
	C, t[62] = madd1(x[0], y[62], C)

	t[63], D = bits.Add64(t[63], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	C, t[55] = madd2(m, mod[56], t[56], C)
	C, t[56] = madd2(m, mod[57], t[57], C)
	C, t[57] = madd2(m, mod[58], t[58], C)
	C, t[58] = madd2(m, mod[59], t[59], C)
	C, t[59] = madd2(m, mod[60], t[60], C)
	C, t[60] = madd2(m, mod[61], t[61], C)
	C, t[61] = madd2(m, mod[62], t[62], C)
	t[62], C = bits.Add64(t[63], C, 0)
	t[63], _ = bits.Add64(0, D, C)

	for j := 1; j < 63; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		C, t[56] = madd2(x[j], y[56], t[56], C)
		C, t[57] = madd2(x[j], y[57], t[57], C)
		C, t[58] = madd2(x[j], y[58], t[58], C)
		C, t[59] = madd2(x[j], y[59], t[59], C)
		C, t[60] = madd2(x[j], y[60], t[60], C)
		C, t[61] = madd2(x[j], y[61], t[61], C)
		C, t[62] = madd2(x[j], y[62], t[62], C)
		t[63], D = bits.Add64(t[63], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		C, t[55] = madd2(m, mod[56], t[56], C)
		C, t[56] = madd2(m, mod[57], t[57], C)
		C, t[57] = madd2(m, mod[58], t[58], C)
		C, t[58] = madd2(m, mod[59], t[59], C)
		C, t[59] = madd2(m, mod[60], t[60], C)
		C, t[60] = madd2(m, mod[61], t[61], C)
		C, t[61] = madd2(m, mod[62], t[62], C)
		t[62], C = bits.Add64(t[63], C, 0)
		t[63], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)
	z[56], D = bits.Sub64(t[56], mod[56], D)
	z[57], D = bits.Sub64(t[57], mod[57], D)
	z[58], D = bits.Sub64(t[58], mod[58], D)
	z[59], D = bits.Sub64(t[59], mod[59], D)
	z[60], D = bits.Sub64(t[60], mod[60], D)
	z[61], D = bits.Sub64(t[61], mod[61], D)
	z[62], D = bits.Sub64(t[62], mod[62], D)

	var src []uint64
	if D != 0 && t[63] == 0 {
		src = t[:63]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[62])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[61])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[60])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[59])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[58])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[57])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[56])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[55])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[54])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[53])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[52])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[51])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[50])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[49])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[48])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[47])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[46])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[45])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[44])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[43])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[42])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[41])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[40])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[39])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[38])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[37])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[36])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[35])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[34])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[33])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[32])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[31])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[30])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[29])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[28])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[27])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[26])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[25])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[24])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[23])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[22])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[21])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[20])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[19])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[18])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[17])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[16])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[15])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[14])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[13])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[12])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[11])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[10])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[9])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[8])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[7])
	binary.BigEndian.PutUint64(z_bytes[448:456], src[6])
	binary.BigEndian.PutUint64(z_bytes[456:464], src[5])
	binary.BigEndian.PutUint64(z_bytes[464:472], src[4])
	binary.BigEndian.PutUint64(z_bytes[472:480], src[3])
	binary.BigEndian.PutUint64(z_bytes[480:488], src[2])
	binary.BigEndian.PutUint64(z_bytes[488:496], src[1])
	binary.BigEndian.PutUint64(z_bytes[496:504], src[0])

	return nil
}

func MulMontNonUnrolled4096(ctx *Field, z_bytes, x_bytes, y_bytes []byte) error {
	var x, y, z [64]uint64

	// conversion to little-endian limb-order, system limb-endianess
	x[63] = binary.BigEndian.Uint64(x_bytes[0:8])
	y[63] = binary.BigEndian.Uint64(y_bytes[0:8])
	x[62] = binary.BigEndian.Uint64(x_bytes[8:16])
	y[62] = binary.BigEndian.Uint64(y_bytes[8:16])
	x[61] = binary.BigEndian.Uint64(x_bytes[16:24])
	y[61] = binary.BigEndian.Uint64(y_bytes[16:24])
	x[60] = binary.BigEndian.Uint64(x_bytes[24:32])
	y[60] = binary.BigEndian.Uint64(y_bytes[24:32])
	x[59] = binary.BigEndian.Uint64(x_bytes[32:40])
	y[59] = binary.BigEndian.Uint64(y_bytes[32:40])
	x[58] = binary.BigEndian.Uint64(x_bytes[40:48])
	y[58] = binary.BigEndian.Uint64(y_bytes[40:48])
	x[57] = binary.BigEndian.Uint64(x_bytes[48:56])
	y[57] = binary.BigEndian.Uint64(y_bytes[48:56])
	x[56] = binary.BigEndian.Uint64(x_bytes[56:64])
	y[56] = binary.BigEndian.Uint64(y_bytes[56:64])
	x[55] = binary.BigEndian.Uint64(x_bytes[64:72])
	y[55] = binary.BigEndian.Uint64(y_bytes[64:72])
	x[54] = binary.BigEndian.Uint64(x_bytes[72:80])
	y[54] = binary.BigEndian.Uint64(y_bytes[72:80])
	x[53] = binary.BigEndian.Uint64(x_bytes[80:88])
	y[53] = binary.BigEndian.Uint64(y_bytes[80:88])
	x[52] = binary.BigEndian.Uint64(x_bytes[88:96])
	y[52] = binary.BigEndian.Uint64(y_bytes[88:96])
	x[51] = binary.BigEndian.Uint64(x_bytes[96:104])
	y[51] = binary.BigEndian.Uint64(y_bytes[96:104])
	x[50] = binary.BigEndian.Uint64(x_bytes[104:112])
	y[50] = binary.BigEndian.Uint64(y_bytes[104:112])
	x[49] = binary.BigEndian.Uint64(x_bytes[112:120])
	y[49] = binary.BigEndian.Uint64(y_bytes[112:120])
	x[48] = binary.BigEndian.Uint64(x_bytes[120:128])
	y[48] = binary.BigEndian.Uint64(y_bytes[120:128])
	x[47] = binary.BigEndian.Uint64(x_bytes[128:136])
	y[47] = binary.BigEndian.Uint64(y_bytes[128:136])
	x[46] = binary.BigEndian.Uint64(x_bytes[136:144])
	y[46] = binary.BigEndian.Uint64(y_bytes[136:144])
	x[45] = binary.BigEndian.Uint64(x_bytes[144:152])
	y[45] = binary.BigEndian.Uint64(y_bytes[144:152])
	x[44] = binary.BigEndian.Uint64(x_bytes[152:160])
	y[44] = binary.BigEndian.Uint64(y_bytes[152:160])
	x[43] = binary.BigEndian.Uint64(x_bytes[160:168])
	y[43] = binary.BigEndian.Uint64(y_bytes[160:168])
	x[42] = binary.BigEndian.Uint64(x_bytes[168:176])
	y[42] = binary.BigEndian.Uint64(y_bytes[168:176])
	x[41] = binary.BigEndian.Uint64(x_bytes[176:184])
	y[41] = binary.BigEndian.Uint64(y_bytes[176:184])
	x[40] = binary.BigEndian.Uint64(x_bytes[184:192])
	y[40] = binary.BigEndian.Uint64(y_bytes[184:192])
	x[39] = binary.BigEndian.Uint64(x_bytes[192:200])
	y[39] = binary.BigEndian.Uint64(y_bytes[192:200])
	x[38] = binary.BigEndian.Uint64(x_bytes[200:208])
	y[38] = binary.BigEndian.Uint64(y_bytes[200:208])
	x[37] = binary.BigEndian.Uint64(x_bytes[208:216])
	y[37] = binary.BigEndian.Uint64(y_bytes[208:216])
	x[36] = binary.BigEndian.Uint64(x_bytes[216:224])
	y[36] = binary.BigEndian.Uint64(y_bytes[216:224])
	x[35] = binary.BigEndian.Uint64(x_bytes[224:232])
	y[35] = binary.BigEndian.Uint64(y_bytes[224:232])
	x[34] = binary.BigEndian.Uint64(x_bytes[232:240])
	y[34] = binary.BigEndian.Uint64(y_bytes[232:240])
	x[33] = binary.BigEndian.Uint64(x_bytes[240:248])
	y[33] = binary.BigEndian.Uint64(y_bytes[240:248])
	x[32] = binary.BigEndian.Uint64(x_bytes[248:256])
	y[32] = binary.BigEndian.Uint64(y_bytes[248:256])
	x[31] = binary.BigEndian.Uint64(x_bytes[256:264])
	y[31] = binary.BigEndian.Uint64(y_bytes[256:264])
	x[30] = binary.BigEndian.Uint64(x_bytes[264:272])
	y[30] = binary.BigEndian.Uint64(y_bytes[264:272])
	x[29] = binary.BigEndian.Uint64(x_bytes[272:280])
	y[29] = binary.BigEndian.Uint64(y_bytes[272:280])
	x[28] = binary.BigEndian.Uint64(x_bytes[280:288])
	y[28] = binary.BigEndian.Uint64(y_bytes[280:288])
	x[27] = binary.BigEndian.Uint64(x_bytes[288:296])
	y[27] = binary.BigEndian.Uint64(y_bytes[288:296])
	x[26] = binary.BigEndian.Uint64(x_bytes[296:304])
	y[26] = binary.BigEndian.Uint64(y_bytes[296:304])
	x[25] = binary.BigEndian.Uint64(x_bytes[304:312])
	y[25] = binary.BigEndian.Uint64(y_bytes[304:312])
	x[24] = binary.BigEndian.Uint64(x_bytes[312:320])
	y[24] = binary.BigEndian.Uint64(y_bytes[312:320])
	x[23] = binary.BigEndian.Uint64(x_bytes[320:328])
	y[23] = binary.BigEndian.Uint64(y_bytes[320:328])
	x[22] = binary.BigEndian.Uint64(x_bytes[328:336])
	y[22] = binary.BigEndian.Uint64(y_bytes[328:336])
	x[21] = binary.BigEndian.Uint64(x_bytes[336:344])
	y[21] = binary.BigEndian.Uint64(y_bytes[336:344])
	x[20] = binary.BigEndian.Uint64(x_bytes[344:352])
	y[20] = binary.BigEndian.Uint64(y_bytes[344:352])
	x[19] = binary.BigEndian.Uint64(x_bytes[352:360])
	y[19] = binary.BigEndian.Uint64(y_bytes[352:360])
	x[18] = binary.BigEndian.Uint64(x_bytes[360:368])
	y[18] = binary.BigEndian.Uint64(y_bytes[360:368])
	x[17] = binary.BigEndian.Uint64(x_bytes[368:376])
	y[17] = binary.BigEndian.Uint64(y_bytes[368:376])
	x[16] = binary.BigEndian.Uint64(x_bytes[376:384])
	y[16] = binary.BigEndian.Uint64(y_bytes[376:384])
	x[15] = binary.BigEndian.Uint64(x_bytes[384:392])
	y[15] = binary.BigEndian.Uint64(y_bytes[384:392])
	x[14] = binary.BigEndian.Uint64(x_bytes[392:400])
	y[14] = binary.BigEndian.Uint64(y_bytes[392:400])
	x[13] = binary.BigEndian.Uint64(x_bytes[400:408])
	y[13] = binary.BigEndian.Uint64(y_bytes[400:408])
	x[12] = binary.BigEndian.Uint64(x_bytes[408:416])
	y[12] = binary.BigEndian.Uint64(y_bytes[408:416])
	x[11] = binary.BigEndian.Uint64(x_bytes[416:424])
	y[11] = binary.BigEndian.Uint64(y_bytes[416:424])
	x[10] = binary.BigEndian.Uint64(x_bytes[424:432])
	y[10] = binary.BigEndian.Uint64(y_bytes[424:432])
	x[9] = binary.BigEndian.Uint64(x_bytes[432:440])
	y[9] = binary.BigEndian.Uint64(y_bytes[432:440])
	x[8] = binary.BigEndian.Uint64(x_bytes[440:448])
	y[8] = binary.BigEndian.Uint64(y_bytes[440:448])
	x[7] = binary.BigEndian.Uint64(x_bytes[448:456])
	y[7] = binary.BigEndian.Uint64(y_bytes[448:456])
	x[6] = binary.BigEndian.Uint64(x_bytes[456:464])
	y[6] = binary.BigEndian.Uint64(y_bytes[456:464])
	x[5] = binary.BigEndian.Uint64(x_bytes[464:472])
	y[5] = binary.BigEndian.Uint64(y_bytes[464:472])
	x[4] = binary.BigEndian.Uint64(x_bytes[472:480])
	y[4] = binary.BigEndian.Uint64(y_bytes[472:480])
	x[3] = binary.BigEndian.Uint64(x_bytes[480:488])
	y[3] = binary.BigEndian.Uint64(y_bytes[480:488])
	x[2] = binary.BigEndian.Uint64(x_bytes[488:496])
	y[2] = binary.BigEndian.Uint64(y_bytes[488:496])
	x[1] = binary.BigEndian.Uint64(x_bytes[496:504])
	y[1] = binary.BigEndian.Uint64(y_bytes[496:504])
	x[0] = binary.BigEndian.Uint64(x_bytes[504:512])
	y[0] = binary.BigEndian.Uint64(y_bytes[504:512])

	/*
	   xInt := new(big.Int).SetBytes(x_bytes[0:512])
	   yInt := new(big.Int).SetBytes(y_bytes[0:512])
	   modInt := ctx.ModulusNonInterleaved
	*/
	//fmt.Printf("mulmont\n x=%s\n y=%s\n mod=%s\n", xInt.String(), yInt.String(), modInt.String())

	mod := ctx.ModulusLimbs
	var t [65]uint64
	var D uint64
	var m, C uint64

	fmt.Println("limbCount is 64")
	fmt.Printf("inside mulmont.\n x = %x\n y = %x\n mod = %x\n", x, y, ctx.ModulusLimbs)

	var gteC1, gteC2 uint64
	_, gteC1 = bits.Sub64(mod[0], x[0], gteC1)
	_, gteC1 = bits.Sub64(mod[1], x[1], gteC1)
	_, gteC1 = bits.Sub64(mod[2], x[2], gteC1)
	_, gteC1 = bits.Sub64(mod[3], x[3], gteC1)
	_, gteC1 = bits.Sub64(mod[4], x[4], gteC1)
	_, gteC1 = bits.Sub64(mod[5], x[5], gteC1)
	_, gteC1 = bits.Sub64(mod[6], x[6], gteC1)
	_, gteC1 = bits.Sub64(mod[7], x[7], gteC1)
	_, gteC1 = bits.Sub64(mod[8], x[8], gteC1)
	_, gteC1 = bits.Sub64(mod[9], x[9], gteC1)
	_, gteC1 = bits.Sub64(mod[10], x[10], gteC1)
	_, gteC1 = bits.Sub64(mod[11], x[11], gteC1)
	_, gteC1 = bits.Sub64(mod[12], x[12], gteC1)
	_, gteC1 = bits.Sub64(mod[13], x[13], gteC1)
	_, gteC1 = bits.Sub64(mod[14], x[14], gteC1)
	_, gteC1 = bits.Sub64(mod[15], x[15], gteC1)
	_, gteC1 = bits.Sub64(mod[16], x[16], gteC1)
	_, gteC1 = bits.Sub64(mod[17], x[17], gteC1)
	_, gteC1 = bits.Sub64(mod[18], x[18], gteC1)
	_, gteC1 = bits.Sub64(mod[19], x[19], gteC1)
	_, gteC1 = bits.Sub64(mod[20], x[20], gteC1)
	_, gteC1 = bits.Sub64(mod[21], x[21], gteC1)
	_, gteC1 = bits.Sub64(mod[22], x[22], gteC1)
	_, gteC1 = bits.Sub64(mod[23], x[23], gteC1)
	_, gteC1 = bits.Sub64(mod[24], x[24], gteC1)
	_, gteC1 = bits.Sub64(mod[25], x[25], gteC1)
	_, gteC1 = bits.Sub64(mod[26], x[26], gteC1)
	_, gteC1 = bits.Sub64(mod[27], x[27], gteC1)
	_, gteC1 = bits.Sub64(mod[28], x[28], gteC1)
	_, gteC1 = bits.Sub64(mod[29], x[29], gteC1)
	_, gteC1 = bits.Sub64(mod[30], x[30], gteC1)
	_, gteC1 = bits.Sub64(mod[31], x[31], gteC1)
	_, gteC1 = bits.Sub64(mod[32], x[32], gteC1)
	_, gteC1 = bits.Sub64(mod[33], x[33], gteC1)
	_, gteC1 = bits.Sub64(mod[34], x[34], gteC1)
	_, gteC1 = bits.Sub64(mod[35], x[35], gteC1)
	_, gteC1 = bits.Sub64(mod[36], x[36], gteC1)
	_, gteC1 = bits.Sub64(mod[37], x[37], gteC1)
	_, gteC1 = bits.Sub64(mod[38], x[38], gteC1)
	_, gteC1 = bits.Sub64(mod[39], x[39], gteC1)
	_, gteC1 = bits.Sub64(mod[40], x[40], gteC1)
	_, gteC1 = bits.Sub64(mod[41], x[41], gteC1)
	_, gteC1 = bits.Sub64(mod[42], x[42], gteC1)
	_, gteC1 = bits.Sub64(mod[43], x[43], gteC1)
	_, gteC1 = bits.Sub64(mod[44], x[44], gteC1)
	_, gteC1 = bits.Sub64(mod[45], x[45], gteC1)
	_, gteC1 = bits.Sub64(mod[46], x[46], gteC1)
	_, gteC1 = bits.Sub64(mod[47], x[47], gteC1)
	_, gteC1 = bits.Sub64(mod[48], x[48], gteC1)
	_, gteC1 = bits.Sub64(mod[49], x[49], gteC1)
	_, gteC1 = bits.Sub64(mod[50], x[50], gteC1)
	_, gteC1 = bits.Sub64(mod[51], x[51], gteC1)
	_, gteC1 = bits.Sub64(mod[52], x[52], gteC1)
	_, gteC1 = bits.Sub64(mod[53], x[53], gteC1)
	_, gteC1 = bits.Sub64(mod[54], x[54], gteC1)
	_, gteC1 = bits.Sub64(mod[55], x[55], gteC1)
	_, gteC1 = bits.Sub64(mod[56], x[56], gteC1)
	_, gteC1 = bits.Sub64(mod[57], x[57], gteC1)
	_, gteC1 = bits.Sub64(mod[58], x[58], gteC1)
	_, gteC1 = bits.Sub64(mod[59], x[59], gteC1)
	_, gteC1 = bits.Sub64(mod[60], x[60], gteC1)
	_, gteC1 = bits.Sub64(mod[61], x[61], gteC1)
	_, gteC1 = bits.Sub64(mod[62], x[62], gteC1)
	_, gteC1 = bits.Sub64(mod[63], x[63], gteC1)
	_, gteC2 = bits.Sub64(mod[0], y[0], gteC2)
	_, gteC2 = bits.Sub64(mod[1], y[1], gteC2)
	_, gteC2 = bits.Sub64(mod[2], y[2], gteC2)
	_, gteC2 = bits.Sub64(mod[3], y[3], gteC2)
	_, gteC2 = bits.Sub64(mod[4], y[4], gteC2)
	_, gteC2 = bits.Sub64(mod[5], y[5], gteC2)
	_, gteC2 = bits.Sub64(mod[6], y[6], gteC2)
	_, gteC2 = bits.Sub64(mod[7], y[7], gteC2)
	_, gteC2 = bits.Sub64(mod[8], y[8], gteC2)
	_, gteC2 = bits.Sub64(mod[9], y[9], gteC2)
	_, gteC2 = bits.Sub64(mod[10], y[10], gteC2)
	_, gteC2 = bits.Sub64(mod[11], y[11], gteC2)
	_, gteC2 = bits.Sub64(mod[12], y[12], gteC2)
	_, gteC2 = bits.Sub64(mod[13], y[13], gteC2)
	_, gteC2 = bits.Sub64(mod[14], y[14], gteC2)
	_, gteC2 = bits.Sub64(mod[15], y[15], gteC2)
	_, gteC2 = bits.Sub64(mod[16], y[16], gteC2)
	_, gteC2 = bits.Sub64(mod[17], y[17], gteC2)
	_, gteC2 = bits.Sub64(mod[18], y[18], gteC2)
	_, gteC2 = bits.Sub64(mod[19], y[19], gteC2)
	_, gteC2 = bits.Sub64(mod[20], y[20], gteC2)
	_, gteC2 = bits.Sub64(mod[21], y[21], gteC2)
	_, gteC2 = bits.Sub64(mod[22], y[22], gteC2)
	_, gteC2 = bits.Sub64(mod[23], y[23], gteC2)
	_, gteC2 = bits.Sub64(mod[24], y[24], gteC2)
	_, gteC2 = bits.Sub64(mod[25], y[25], gteC2)
	_, gteC2 = bits.Sub64(mod[26], y[26], gteC2)
	_, gteC2 = bits.Sub64(mod[27], y[27], gteC2)
	_, gteC2 = bits.Sub64(mod[28], y[28], gteC2)
	_, gteC2 = bits.Sub64(mod[29], y[29], gteC2)
	_, gteC2 = bits.Sub64(mod[30], y[30], gteC2)
	_, gteC2 = bits.Sub64(mod[31], y[31], gteC2)
	_, gteC2 = bits.Sub64(mod[32], y[32], gteC2)
	_, gteC2 = bits.Sub64(mod[33], y[33], gteC2)
	_, gteC2 = bits.Sub64(mod[34], y[34], gteC2)
	_, gteC2 = bits.Sub64(mod[35], y[35], gteC2)
	_, gteC2 = bits.Sub64(mod[36], y[36], gteC2)
	_, gteC2 = bits.Sub64(mod[37], y[37], gteC2)
	_, gteC2 = bits.Sub64(mod[38], y[38], gteC2)
	_, gteC2 = bits.Sub64(mod[39], y[39], gteC2)
	_, gteC2 = bits.Sub64(mod[40], y[40], gteC2)
	_, gteC2 = bits.Sub64(mod[41], y[41], gteC2)
	_, gteC2 = bits.Sub64(mod[42], y[42], gteC2)
	_, gteC2 = bits.Sub64(mod[43], y[43], gteC2)
	_, gteC2 = bits.Sub64(mod[44], y[44], gteC2)
	_, gteC2 = bits.Sub64(mod[45], y[45], gteC2)
	_, gteC2 = bits.Sub64(mod[46], y[46], gteC2)
	_, gteC2 = bits.Sub64(mod[47], y[47], gteC2)
	_, gteC2 = bits.Sub64(mod[48], y[48], gteC2)
	_, gteC2 = bits.Sub64(mod[49], y[49], gteC2)
	_, gteC2 = bits.Sub64(mod[50], y[50], gteC2)
	_, gteC2 = bits.Sub64(mod[51], y[51], gteC2)
	_, gteC2 = bits.Sub64(mod[52], y[52], gteC2)
	_, gteC2 = bits.Sub64(mod[53], y[53], gteC2)
	_, gteC2 = bits.Sub64(mod[54], y[54], gteC2)
	_, gteC2 = bits.Sub64(mod[55], y[55], gteC2)
	_, gteC2 = bits.Sub64(mod[56], y[56], gteC2)
	_, gteC2 = bits.Sub64(mod[57], y[57], gteC2)
	_, gteC2 = bits.Sub64(mod[58], y[58], gteC2)
	_, gteC2 = bits.Sub64(mod[59], y[59], gteC2)
	_, gteC2 = bits.Sub64(mod[60], y[60], gteC2)
	_, gteC2 = bits.Sub64(mod[61], y[61], gteC2)
	_, gteC2 = bits.Sub64(mod[62], y[62], gteC2)
	_, gteC2 = bits.Sub64(mod[63], y[63], gteC2)

	/*
	   fmt.Println()
	   fmt.Println()
	   fmt.Println("foo")
	   fmt.Println(x)
	   fmt.Println(y)
	   fmt.Println(mod)
	*/

	if gteC1 != 0 || gteC2 != 0 {
		return errors.New(fmt.Sprintf("input gte modulus"))
	}

	C, t[0] = bits.Mul64(x[0], y[0])
	C, t[1] = madd1(x[0], y[1], C)
	C, t[2] = madd1(x[0], y[2], C)
	C, t[3] = madd1(x[0], y[3], C)
	C, t[4] = madd1(x[0], y[4], C)
	C, t[5] = madd1(x[0], y[5], C)
	C, t[6] = madd1(x[0], y[6], C)
	C, t[7] = madd1(x[0], y[7], C)
	C, t[8] = madd1(x[0], y[8], C)
	C, t[9] = madd1(x[0], y[9], C)
	C, t[10] = madd1(x[0], y[10], C)
	C, t[11] = madd1(x[0], y[11], C)
	C, t[12] = madd1(x[0], y[12], C)
	C, t[13] = madd1(x[0], y[13], C)
	C, t[14] = madd1(x[0], y[14], C)
	C, t[15] = madd1(x[0], y[15], C)
	C, t[16] = madd1(x[0], y[16], C)
	C, t[17] = madd1(x[0], y[17], C)
	C, t[18] = madd1(x[0], y[18], C)
	C, t[19] = madd1(x[0], y[19], C)
	C, t[20] = madd1(x[0], y[20], C)
	C, t[21] = madd1(x[0], y[21], C)
	C, t[22] = madd1(x[0], y[22], C)
	C, t[23] = madd1(x[0], y[23], C)
	C, t[24] = madd1(x[0], y[24], C)
	C, t[25] = madd1(x[0], y[25], C)
	C, t[26] = madd1(x[0], y[26], C)
	C, t[27] = madd1(x[0], y[27], C)
	C, t[28] = madd1(x[0], y[28], C)
	C, t[29] = madd1(x[0], y[29], C)
	C, t[30] = madd1(x[0], y[30], C)
	C, t[31] = madd1(x[0], y[31], C)
	C, t[32] = madd1(x[0], y[32], C)
	C, t[33] = madd1(x[0], y[33], C)
	C, t[34] = madd1(x[0], y[34], C)
	C, t[35] = madd1(x[0], y[35], C)
	C, t[36] = madd1(x[0], y[36], C)
	C, t[37] = madd1(x[0], y[37], C)
	C, t[38] = madd1(x[0], y[38], C)
	C, t[39] = madd1(x[0], y[39], C)
	C, t[40] = madd1(x[0], y[40], C)
	C, t[41] = madd1(x[0], y[41], C)
	C, t[42] = madd1(x[0], y[42], C)
	C, t[43] = madd1(x[0], y[43], C)
	C, t[44] = madd1(x[0], y[44], C)
	C, t[45] = madd1(x[0], y[45], C)
	C, t[46] = madd1(x[0], y[46], C)
	C, t[47] = madd1(x[0], y[47], C)
	C, t[48] = madd1(x[0], y[48], C)
	C, t[49] = madd1(x[0], y[49], C)
	C, t[50] = madd1(x[0], y[50], C)
	C, t[51] = madd1(x[0], y[51], C)
	C, t[52] = madd1(x[0], y[52], C)
	C, t[53] = madd1(x[0], y[53], C)
	C, t[54] = madd1(x[0], y[54], C)
	C, t[55] = madd1(x[0], y[55], C)
	C, t[56] = madd1(x[0], y[56], C)
	C, t[57] = madd1(x[0], y[57], C)
	C, t[58] = madd1(x[0], y[58], C)
	C, t[59] = madd1(x[0], y[59], C)
	C, t[60] = madd1(x[0], y[60], C)
	C, t[61] = madd1(x[0], y[61], C)
	C, t[62] = madd1(x[0], y[62], C)
	C, t[63] = madd1(x[0], y[63], C)

	t[64], D = bits.Add64(t[64], C, 0)
	// m = t[0]n'[0] mod W
	m = t[0] * ctx.MontParamInterleaved

	// -----------------------------------
	// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
	C = madd0(m, mod[0], t[0])
	C, t[0] = madd2(m, mod[1], t[1], C)
	C, t[1] = madd2(m, mod[2], t[2], C)
	C, t[2] = madd2(m, mod[3], t[3], C)
	C, t[3] = madd2(m, mod[4], t[4], C)
	C, t[4] = madd2(m, mod[5], t[5], C)
	C, t[5] = madd2(m, mod[6], t[6], C)
	C, t[6] = madd2(m, mod[7], t[7], C)
	C, t[7] = madd2(m, mod[8], t[8], C)
	C, t[8] = madd2(m, mod[9], t[9], C)
	C, t[9] = madd2(m, mod[10], t[10], C)
	C, t[10] = madd2(m, mod[11], t[11], C)
	C, t[11] = madd2(m, mod[12], t[12], C)
	C, t[12] = madd2(m, mod[13], t[13], C)
	C, t[13] = madd2(m, mod[14], t[14], C)
	C, t[14] = madd2(m, mod[15], t[15], C)
	C, t[15] = madd2(m, mod[16], t[16], C)
	C, t[16] = madd2(m, mod[17], t[17], C)
	C, t[17] = madd2(m, mod[18], t[18], C)
	C, t[18] = madd2(m, mod[19], t[19], C)
	C, t[19] = madd2(m, mod[20], t[20], C)
	C, t[20] = madd2(m, mod[21], t[21], C)
	C, t[21] = madd2(m, mod[22], t[22], C)
	C, t[22] = madd2(m, mod[23], t[23], C)
	C, t[23] = madd2(m, mod[24], t[24], C)
	C, t[24] = madd2(m, mod[25], t[25], C)
	C, t[25] = madd2(m, mod[26], t[26], C)
	C, t[26] = madd2(m, mod[27], t[27], C)
	C, t[27] = madd2(m, mod[28], t[28], C)
	C, t[28] = madd2(m, mod[29], t[29], C)
	C, t[29] = madd2(m, mod[30], t[30], C)
	C, t[30] = madd2(m, mod[31], t[31], C)
	C, t[31] = madd2(m, mod[32], t[32], C)
	C, t[32] = madd2(m, mod[33], t[33], C)
	C, t[33] = madd2(m, mod[34], t[34], C)
	C, t[34] = madd2(m, mod[35], t[35], C)
	C, t[35] = madd2(m, mod[36], t[36], C)
	C, t[36] = madd2(m, mod[37], t[37], C)
	C, t[37] = madd2(m, mod[38], t[38], C)
	C, t[38] = madd2(m, mod[39], t[39], C)
	C, t[39] = madd2(m, mod[40], t[40], C)
	C, t[40] = madd2(m, mod[41], t[41], C)
	C, t[41] = madd2(m, mod[42], t[42], C)
	C, t[42] = madd2(m, mod[43], t[43], C)
	C, t[43] = madd2(m, mod[44], t[44], C)
	C, t[44] = madd2(m, mod[45], t[45], C)
	C, t[45] = madd2(m, mod[46], t[46], C)
	C, t[46] = madd2(m, mod[47], t[47], C)
	C, t[47] = madd2(m, mod[48], t[48], C)
	C, t[48] = madd2(m, mod[49], t[49], C)
	C, t[49] = madd2(m, mod[50], t[50], C)
	C, t[50] = madd2(m, mod[51], t[51], C)
	C, t[51] = madd2(m, mod[52], t[52], C)
	C, t[52] = madd2(m, mod[53], t[53], C)
	C, t[53] = madd2(m, mod[54], t[54], C)
	C, t[54] = madd2(m, mod[55], t[55], C)
	C, t[55] = madd2(m, mod[56], t[56], C)
	C, t[56] = madd2(m, mod[57], t[57], C)
	C, t[57] = madd2(m, mod[58], t[58], C)
	C, t[58] = madd2(m, mod[59], t[59], C)
	C, t[59] = madd2(m, mod[60], t[60], C)
	C, t[60] = madd2(m, mod[61], t[61], C)
	C, t[61] = madd2(m, mod[62], t[62], C)
	C, t[62] = madd2(m, mod[63], t[63], C)
	t[63], C = bits.Add64(t[64], C, 0)
	t[64], _ = bits.Add64(0, D, C)

	for j := 1; j < 64; j++ {
		//  first inner loop (second iteration)
		C, t[0] = madd1(x[j], y[0], t[0])
		C, t[1] = madd2(x[j], y[1], t[1], C)
		C, t[2] = madd2(x[j], y[2], t[2], C)
		C, t[3] = madd2(x[j], y[3], t[3], C)
		C, t[4] = madd2(x[j], y[4], t[4], C)
		C, t[5] = madd2(x[j], y[5], t[5], C)
		C, t[6] = madd2(x[j], y[6], t[6], C)
		C, t[7] = madd2(x[j], y[7], t[7], C)
		C, t[8] = madd2(x[j], y[8], t[8], C)
		C, t[9] = madd2(x[j], y[9], t[9], C)
		C, t[10] = madd2(x[j], y[10], t[10], C)
		C, t[11] = madd2(x[j], y[11], t[11], C)
		C, t[12] = madd2(x[j], y[12], t[12], C)
		C, t[13] = madd2(x[j], y[13], t[13], C)
		C, t[14] = madd2(x[j], y[14], t[14], C)
		C, t[15] = madd2(x[j], y[15], t[15], C)
		C, t[16] = madd2(x[j], y[16], t[16], C)
		C, t[17] = madd2(x[j], y[17], t[17], C)
		C, t[18] = madd2(x[j], y[18], t[18], C)
		C, t[19] = madd2(x[j], y[19], t[19], C)
		C, t[20] = madd2(x[j], y[20], t[20], C)
		C, t[21] = madd2(x[j], y[21], t[21], C)
		C, t[22] = madd2(x[j], y[22], t[22], C)
		C, t[23] = madd2(x[j], y[23], t[23], C)
		C, t[24] = madd2(x[j], y[24], t[24], C)
		C, t[25] = madd2(x[j], y[25], t[25], C)
		C, t[26] = madd2(x[j], y[26], t[26], C)
		C, t[27] = madd2(x[j], y[27], t[27], C)
		C, t[28] = madd2(x[j], y[28], t[28], C)
		C, t[29] = madd2(x[j], y[29], t[29], C)
		C, t[30] = madd2(x[j], y[30], t[30], C)
		C, t[31] = madd2(x[j], y[31], t[31], C)
		C, t[32] = madd2(x[j], y[32], t[32], C)
		C, t[33] = madd2(x[j], y[33], t[33], C)
		C, t[34] = madd2(x[j], y[34], t[34], C)
		C, t[35] = madd2(x[j], y[35], t[35], C)
		C, t[36] = madd2(x[j], y[36], t[36], C)
		C, t[37] = madd2(x[j], y[37], t[37], C)
		C, t[38] = madd2(x[j], y[38], t[38], C)
		C, t[39] = madd2(x[j], y[39], t[39], C)
		C, t[40] = madd2(x[j], y[40], t[40], C)
		C, t[41] = madd2(x[j], y[41], t[41], C)
		C, t[42] = madd2(x[j], y[42], t[42], C)
		C, t[43] = madd2(x[j], y[43], t[43], C)
		C, t[44] = madd2(x[j], y[44], t[44], C)
		C, t[45] = madd2(x[j], y[45], t[45], C)
		C, t[46] = madd2(x[j], y[46], t[46], C)
		C, t[47] = madd2(x[j], y[47], t[47], C)
		C, t[48] = madd2(x[j], y[48], t[48], C)
		C, t[49] = madd2(x[j], y[49], t[49], C)
		C, t[50] = madd2(x[j], y[50], t[50], C)
		C, t[51] = madd2(x[j], y[51], t[51], C)
		C, t[52] = madd2(x[j], y[52], t[52], C)
		C, t[53] = madd2(x[j], y[53], t[53], C)
		C, t[54] = madd2(x[j], y[54], t[54], C)
		C, t[55] = madd2(x[j], y[55], t[55], C)
		C, t[56] = madd2(x[j], y[56], t[56], C)
		C, t[57] = madd2(x[j], y[57], t[57], C)
		C, t[58] = madd2(x[j], y[58], t[58], C)
		C, t[59] = madd2(x[j], y[59], t[59], C)
		C, t[60] = madd2(x[j], y[60], t[60], C)
		C, t[61] = madd2(x[j], y[61], t[61], C)
		C, t[62] = madd2(x[j], y[62], t[62], C)
		C, t[63] = madd2(x[j], y[63], t[63], C)
		t[64], D = bits.Add64(t[64], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved

		// -----------------------------------
		// Second inner loop: reduce 1 limb at a time (B**1, B**2, ...)
		C = madd0(m, mod[0], t[0])
		C, t[0] = madd2(m, mod[1], t[1], C)
		C, t[1] = madd2(m, mod[2], t[2], C)
		C, t[2] = madd2(m, mod[3], t[3], C)
		C, t[3] = madd2(m, mod[4], t[4], C)
		C, t[4] = madd2(m, mod[5], t[5], C)
		C, t[5] = madd2(m, mod[6], t[6], C)
		C, t[6] = madd2(m, mod[7], t[7], C)
		C, t[7] = madd2(m, mod[8], t[8], C)
		C, t[8] = madd2(m, mod[9], t[9], C)
		C, t[9] = madd2(m, mod[10], t[10], C)
		C, t[10] = madd2(m, mod[11], t[11], C)
		C, t[11] = madd2(m, mod[12], t[12], C)
		C, t[12] = madd2(m, mod[13], t[13], C)
		C, t[13] = madd2(m, mod[14], t[14], C)
		C, t[14] = madd2(m, mod[15], t[15], C)
		C, t[15] = madd2(m, mod[16], t[16], C)
		C, t[16] = madd2(m, mod[17], t[17], C)
		C, t[17] = madd2(m, mod[18], t[18], C)
		C, t[18] = madd2(m, mod[19], t[19], C)
		C, t[19] = madd2(m, mod[20], t[20], C)
		C, t[20] = madd2(m, mod[21], t[21], C)
		C, t[21] = madd2(m, mod[22], t[22], C)
		C, t[22] = madd2(m, mod[23], t[23], C)
		C, t[23] = madd2(m, mod[24], t[24], C)
		C, t[24] = madd2(m, mod[25], t[25], C)
		C, t[25] = madd2(m, mod[26], t[26], C)
		C, t[26] = madd2(m, mod[27], t[27], C)
		C, t[27] = madd2(m, mod[28], t[28], C)
		C, t[28] = madd2(m, mod[29], t[29], C)
		C, t[29] = madd2(m, mod[30], t[30], C)
		C, t[30] = madd2(m, mod[31], t[31], C)
		C, t[31] = madd2(m, mod[32], t[32], C)
		C, t[32] = madd2(m, mod[33], t[33], C)
		C, t[33] = madd2(m, mod[34], t[34], C)
		C, t[34] = madd2(m, mod[35], t[35], C)
		C, t[35] = madd2(m, mod[36], t[36], C)
		C, t[36] = madd2(m, mod[37], t[37], C)
		C, t[37] = madd2(m, mod[38], t[38], C)
		C, t[38] = madd2(m, mod[39], t[39], C)
		C, t[39] = madd2(m, mod[40], t[40], C)
		C, t[40] = madd2(m, mod[41], t[41], C)
		C, t[41] = madd2(m, mod[42], t[42], C)
		C, t[42] = madd2(m, mod[43], t[43], C)
		C, t[43] = madd2(m, mod[44], t[44], C)
		C, t[44] = madd2(m, mod[45], t[45], C)
		C, t[45] = madd2(m, mod[46], t[46], C)
		C, t[46] = madd2(m, mod[47], t[47], C)
		C, t[47] = madd2(m, mod[48], t[48], C)
		C, t[48] = madd2(m, mod[49], t[49], C)
		C, t[49] = madd2(m, mod[50], t[50], C)
		C, t[50] = madd2(m, mod[51], t[51], C)
		C, t[51] = madd2(m, mod[52], t[52], C)
		C, t[52] = madd2(m, mod[53], t[53], C)
		C, t[53] = madd2(m, mod[54], t[54], C)
		C, t[54] = madd2(m, mod[55], t[55], C)
		C, t[55] = madd2(m, mod[56], t[56], C)
		C, t[56] = madd2(m, mod[57], t[57], C)
		C, t[57] = madd2(m, mod[58], t[58], C)
		C, t[58] = madd2(m, mod[59], t[59], C)
		C, t[59] = madd2(m, mod[60], t[60], C)
		C, t[60] = madd2(m, mod[61], t[61], C)
		C, t[61] = madd2(m, mod[62], t[62], C)
		C, t[62] = madd2(m, mod[63], t[63], C)
		t[63], C = bits.Add64(t[64], C, 0)
		t[64], _ = bits.Add64(0, D, C)
	}
	z[0], D = bits.Sub64(t[0], mod[0], 0)
	z[1], D = bits.Sub64(t[1], mod[1], D)
	z[2], D = bits.Sub64(t[2], mod[2], D)
	z[3], D = bits.Sub64(t[3], mod[3], D)
	z[4], D = bits.Sub64(t[4], mod[4], D)
	z[5], D = bits.Sub64(t[5], mod[5], D)
	z[6], D = bits.Sub64(t[6], mod[6], D)
	z[7], D = bits.Sub64(t[7], mod[7], D)
	z[8], D = bits.Sub64(t[8], mod[8], D)
	z[9], D = bits.Sub64(t[9], mod[9], D)
	z[10], D = bits.Sub64(t[10], mod[10], D)
	z[11], D = bits.Sub64(t[11], mod[11], D)
	z[12], D = bits.Sub64(t[12], mod[12], D)
	z[13], D = bits.Sub64(t[13], mod[13], D)
	z[14], D = bits.Sub64(t[14], mod[14], D)
	z[15], D = bits.Sub64(t[15], mod[15], D)
	z[16], D = bits.Sub64(t[16], mod[16], D)
	z[17], D = bits.Sub64(t[17], mod[17], D)
	z[18], D = bits.Sub64(t[18], mod[18], D)
	z[19], D = bits.Sub64(t[19], mod[19], D)
	z[20], D = bits.Sub64(t[20], mod[20], D)
	z[21], D = bits.Sub64(t[21], mod[21], D)
	z[22], D = bits.Sub64(t[22], mod[22], D)
	z[23], D = bits.Sub64(t[23], mod[23], D)
	z[24], D = bits.Sub64(t[24], mod[24], D)
	z[25], D = bits.Sub64(t[25], mod[25], D)
	z[26], D = bits.Sub64(t[26], mod[26], D)
	z[27], D = bits.Sub64(t[27], mod[27], D)
	z[28], D = bits.Sub64(t[28], mod[28], D)
	z[29], D = bits.Sub64(t[29], mod[29], D)
	z[30], D = bits.Sub64(t[30], mod[30], D)
	z[31], D = bits.Sub64(t[31], mod[31], D)
	z[32], D = bits.Sub64(t[32], mod[32], D)
	z[33], D = bits.Sub64(t[33], mod[33], D)
	z[34], D = bits.Sub64(t[34], mod[34], D)
	z[35], D = bits.Sub64(t[35], mod[35], D)
	z[36], D = bits.Sub64(t[36], mod[36], D)
	z[37], D = bits.Sub64(t[37], mod[37], D)
	z[38], D = bits.Sub64(t[38], mod[38], D)
	z[39], D = bits.Sub64(t[39], mod[39], D)
	z[40], D = bits.Sub64(t[40], mod[40], D)
	z[41], D = bits.Sub64(t[41], mod[41], D)
	z[42], D = bits.Sub64(t[42], mod[42], D)
	z[43], D = bits.Sub64(t[43], mod[43], D)
	z[44], D = bits.Sub64(t[44], mod[44], D)
	z[45], D = bits.Sub64(t[45], mod[45], D)
	z[46], D = bits.Sub64(t[46], mod[46], D)
	z[47], D = bits.Sub64(t[47], mod[47], D)
	z[48], D = bits.Sub64(t[48], mod[48], D)
	z[49], D = bits.Sub64(t[49], mod[49], D)
	z[50], D = bits.Sub64(t[50], mod[50], D)
	z[51], D = bits.Sub64(t[51], mod[51], D)
	z[52], D = bits.Sub64(t[52], mod[52], D)
	z[53], D = bits.Sub64(t[53], mod[53], D)
	z[54], D = bits.Sub64(t[54], mod[54], D)
	z[55], D = bits.Sub64(t[55], mod[55], D)
	z[56], D = bits.Sub64(t[56], mod[56], D)
	z[57], D = bits.Sub64(t[57], mod[57], D)
	z[58], D = bits.Sub64(t[58], mod[58], D)
	z[59], D = bits.Sub64(t[59], mod[59], D)
	z[60], D = bits.Sub64(t[60], mod[60], D)
	z[61], D = bits.Sub64(t[61], mod[61], D)
	z[62], D = bits.Sub64(t[62], mod[62], D)
	z[63], D = bits.Sub64(t[63], mod[63], D)

	var src []uint64
	if D != 0 && t[64] == 0 {
		src = t[:64]
	} else {
		src = z[:]
	}
	binary.BigEndian.PutUint64(z_bytes[0:8], src[63])
	binary.BigEndian.PutUint64(z_bytes[8:16], src[62])
	binary.BigEndian.PutUint64(z_bytes[16:24], src[61])
	binary.BigEndian.PutUint64(z_bytes[24:32], src[60])
	binary.BigEndian.PutUint64(z_bytes[32:40], src[59])
	binary.BigEndian.PutUint64(z_bytes[40:48], src[58])
	binary.BigEndian.PutUint64(z_bytes[48:56], src[57])
	binary.BigEndian.PutUint64(z_bytes[56:64], src[56])
	binary.BigEndian.PutUint64(z_bytes[64:72], src[55])
	binary.BigEndian.PutUint64(z_bytes[72:80], src[54])
	binary.BigEndian.PutUint64(z_bytes[80:88], src[53])
	binary.BigEndian.PutUint64(z_bytes[88:96], src[52])
	binary.BigEndian.PutUint64(z_bytes[96:104], src[51])
	binary.BigEndian.PutUint64(z_bytes[104:112], src[50])
	binary.BigEndian.PutUint64(z_bytes[112:120], src[49])
	binary.BigEndian.PutUint64(z_bytes[120:128], src[48])
	binary.BigEndian.PutUint64(z_bytes[128:136], src[47])
	binary.BigEndian.PutUint64(z_bytes[136:144], src[46])
	binary.BigEndian.PutUint64(z_bytes[144:152], src[45])
	binary.BigEndian.PutUint64(z_bytes[152:160], src[44])
	binary.BigEndian.PutUint64(z_bytes[160:168], src[43])
	binary.BigEndian.PutUint64(z_bytes[168:176], src[42])
	binary.BigEndian.PutUint64(z_bytes[176:184], src[41])
	binary.BigEndian.PutUint64(z_bytes[184:192], src[40])
	binary.BigEndian.PutUint64(z_bytes[192:200], src[39])
	binary.BigEndian.PutUint64(z_bytes[200:208], src[38])
	binary.BigEndian.PutUint64(z_bytes[208:216], src[37])
	binary.BigEndian.PutUint64(z_bytes[216:224], src[36])
	binary.BigEndian.PutUint64(z_bytes[224:232], src[35])
	binary.BigEndian.PutUint64(z_bytes[232:240], src[34])
	binary.BigEndian.PutUint64(z_bytes[240:248], src[33])
	binary.BigEndian.PutUint64(z_bytes[248:256], src[32])
	binary.BigEndian.PutUint64(z_bytes[256:264], src[31])
	binary.BigEndian.PutUint64(z_bytes[264:272], src[30])
	binary.BigEndian.PutUint64(z_bytes[272:280], src[29])
	binary.BigEndian.PutUint64(z_bytes[280:288], src[28])
	binary.BigEndian.PutUint64(z_bytes[288:296], src[27])
	binary.BigEndian.PutUint64(z_bytes[296:304], src[26])
	binary.BigEndian.PutUint64(z_bytes[304:312], src[25])
	binary.BigEndian.PutUint64(z_bytes[312:320], src[24])
	binary.BigEndian.PutUint64(z_bytes[320:328], src[23])
	binary.BigEndian.PutUint64(z_bytes[328:336], src[22])
	binary.BigEndian.PutUint64(z_bytes[336:344], src[21])
	binary.BigEndian.PutUint64(z_bytes[344:352], src[20])
	binary.BigEndian.PutUint64(z_bytes[352:360], src[19])
	binary.BigEndian.PutUint64(z_bytes[360:368], src[18])
	binary.BigEndian.PutUint64(z_bytes[368:376], src[17])
	binary.BigEndian.PutUint64(z_bytes[376:384], src[16])
	binary.BigEndian.PutUint64(z_bytes[384:392], src[15])
	binary.BigEndian.PutUint64(z_bytes[392:400], src[14])
	binary.BigEndian.PutUint64(z_bytes[400:408], src[13])
	binary.BigEndian.PutUint64(z_bytes[408:416], src[12])
	binary.BigEndian.PutUint64(z_bytes[416:424], src[11])
	binary.BigEndian.PutUint64(z_bytes[424:432], src[10])
	binary.BigEndian.PutUint64(z_bytes[432:440], src[9])
	binary.BigEndian.PutUint64(z_bytes[440:448], src[8])
	binary.BigEndian.PutUint64(z_bytes[448:456], src[7])
	binary.BigEndian.PutUint64(z_bytes[456:464], src[6])
	binary.BigEndian.PutUint64(z_bytes[464:472], src[5])
	binary.BigEndian.PutUint64(z_bytes[472:480], src[4])
	binary.BigEndian.PutUint64(z_bytes[480:488], src[3])
	binary.BigEndian.PutUint64(z_bytes[488:496], src[2])
	binary.BigEndian.PutUint64(z_bytes[496:504], src[1])
	binary.BigEndian.PutUint64(z_bytes[504:512], src[0])

	return nil
}
