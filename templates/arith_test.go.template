package evmmax_arith

import (
	"testing"
	"math/big"
	"encoding/binary"
	"fmt"
)

{{ $limbCount := .LimbCount}}
{{ $lastLimb := sub $limbCount 1}}

// **NOTE** naming confusing.  actually the second-largest modulus (largest would have modinv as 1)
func MaxModulus() [{{$limbCount}}]uint64 {
	mod := {{ makeZeroedLimbs $limbCount}}	

	mod[0] = 0xfdffffffffffffff
	for i := 1; i < {{$limbCount}}; i++ {
		mod[i] = 0xffffffffffffffff
	}

	return mod
}

func Eq_{{$limbCount}}Limbs(x, y [{{$limbCount}}]uint64) bool {
	{{- range $j := intRange 0 $limbCount}}
		if x[{{$j}}] != y[{{$j}}] {
			return false
		}
	{{- end}}

	return true
}

func IntToLimbs_{{$limbCount}}Limbs(val *big.Int) [{{$limbCount}}]uint64 {
	val_bytes := make([]byte, {{$limbCount}} * 8, {{$limbCount}} * 8)
	result := {{ makeZeroedLimbs $limbCount }}
	val.FillBytes(val_bytes)

	for i := 0; i < {{$limbCount}}; i++ {
		result[{{$limbCount}} - (i + 1)] = binary.LittleEndian.Uint64(val_bytes[i * 8: (i + 1) * 8])
	}

	return result
}

func LimbsToInt_{{$limbCount}}Limbs(limbs []uint64) big.Int {
	limbs_bytes := make([]byte, 8 * len(limbs), 8 * len(limbs))
	for i := 0; i < len(limbs); i++ {
		binary.LittleEndian.PutUint64(limbs_bytes[i * 8:(i + 1) * 8], limbs[len(limbs) - (i + 1)])
	}
	
	return *(new(big.Int).SetBytes(limbs_bytes))
}

// does the Python equivalent of pow(-modulus, -1, 1<<64)
func MontConstant(modulus [{{$limbCount}}]uint64) uint64 {
	mod_int := LimbsToInt_{{$limbCount}}Limbs(modulus[:])
	fmt.Println(mod_int.String())
	
	// 1<<64
	aux_mod, _ := new(big.Int).SetString("18446744073709551616", 10)
	negative_one, _ := new(big.Int).SetString("-1", 10)

	mod_int.Mul(&mod_int, negative_one)
	return mod_int.ModInverse(&mod_int, aux_mod).Uint64()
}

func RSquared(modulus [{{$limbCount}}]uint64) [{{$limbCount}}]uint64 {
	mod := LimbsToInt_{{$limbCount}}Limbs(modulus[:])
	r := new(big.Int)
	r.Exp(big.NewInt(2), big.NewInt({{$limbCount}} * 64), &mod)
	r.Mul(r, r)
	r.Mod(r, &mod)
	return IntToLimbs_{{$limbCount}}Limbs(r)
}

func One(size int) [{{$limbCount}}]uint64 {
	one := {{ makeZeroedLimbs $limbCount}}
	one[0] = 1
	return one
}

// test converting 3 to montgomery and back using MulModMont
func TestMulModMontUnrolled_{{$limbCount}}limbs(t *testing.T) {
	test_val := {{ makeZeroedLimbs $limbCount}}
	test_val[{{$lastLimb}}] = 3

	intermediate_val := {{ makeZeroedLimbs $limbCount}}

	mod := MaxModulus()
	mont_const := MontConstant(mod)
	r_squared := RSquared(mod)

	_MulModMont(intermediate_val, test_val, r_squared, mod, mont_const)

	if Eq_{{$limbCount}}Limbs(test_val, intermediate_val) {
		t.Fatalf("conversion to montgomery should modify test val")
	}

	fmt.Println(mont_const)

	_MulModMont(intermediate_val, intermediate_val, One({{$limbCount}}), mod, mont_const)

	if !Eq_{{$limbCount}}Limbs(test_val, intermediate_val) {
		t.Fatalf("conversion back from montgomery failed")
	}
}

func TestAddMod_{{$limbCount}}limbs(t *testing.T) {

}

func TestSubMod_{{$limbCount}}limbs(t *testing.T) {

}
