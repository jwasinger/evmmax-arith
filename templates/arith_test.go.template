package modext

import (
	"testing"
)

{{ $limbCount := .LimbCount}}
{{ $limbBits := .LimbBits}}
{{ $lastLimb := sub $limbCount 1}}

// test converting 3 to montgomery and back using MulModMont
func TestMulModMontUnrolled{{mul $limbCount $limbBits}}(t *testing.T) {
	test_val := make([]uint64, {{$limbCount}}, {{$limbCount}})
	test_val[0] = 3

	intermediate_val := make([]uint64, {{$limbCount}}, {{$limbCount}})

	mod := MaxModulus({{$limbCount}})
	mont_const := MontConstant_Interleaved(mod)
	r_squared := RSquared(mod)

	mulmodMont{{mul $limbCount $limbBits}}(intermediate_val, test_val, r_squared, mod, mont_const)

	if LimbsEq(test_val, intermediate_val) {
		t.Fatalf("conversion to montgomery should modify test val")
	}

	mulmodMont{{mul $limbCount $limbBits}}(intermediate_val, intermediate_val, One({{$limbCount}}), mod, mont_const)

	if !LimbsEq(test_val, intermediate_val) {
		t.Fatalf("conversion back from montgomery failed")
	}
}

func TestAddMod{{mul $limbCount $limbBits}}(t *testing.T) {

}

func TestSubMod{{mul $limbCount $limbBits}}(t *testing.T) {

}

// test converting 3 to montgomery and back using MulModMont
func BenchmarkMulModMontUnrolled{{mul $limbCount $limbBits}}(b *testing.B) {
	test_val := make([]uint64, {{$limbCount}})
	test_val[0] = 3

	intermediate_val := {{ makeZeroedLimbs $limbCount}}

	mod := MaxModulus({{$limbCount}})
	mont_const := MontConstant_Interleaved(mod)
	r_squared := RSquared(mod)
	
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		mulmodMont{{mul $limbCount $limbBits}}(intermediate_val[:], test_val, r_squared[:], mod[:], mont_const)
	}
}
