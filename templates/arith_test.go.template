package evmmax_arith

import (
	"testing"
	"math/big"
	"encoding/binary"
)

{{ $limbCount := .LimbCount}}
{{ $lastLimb := sub $limbCount 1}}

// **NOTE** naming confusing.  actually the second-largest modulus (largest would have modinv as 1)
func MaxModulus_{{$limbCount}}Limbs() [{{$limbCount}}]uint64 {
	mod := {{ makeZeroedLimbs $limbCount}}	

	mod[0] = 0xfffffffffffffffd
	for i := 1; i < {{$limbCount}}; i++ {
		mod[i] = 0xffffffffffffffff
	}

	return mod
}

func Eq_{{$limbCount}}Limbs(x, y [{{$limbCount}}]uint64) bool {
	{{- range $j := intRange 0 $limbCount}}
		if x[{{$j}}] != y[{{$j}}] {
			return false
		}
	{{- end}}

	return true
}

func IntToLimbs_{{$limbCount}}Limbs(val *big.Int) [{{$limbCount}}]uint64 {
	val_bytes := make([]byte, {{$limbCount}} * 8, {{$limbCount}} * 8)
	result := {{ makeZeroedLimbs $limbCount }}
	val.FillBytes(val_bytes)

	for i := 0; i < {{$limbCount}}; i++ {
		result[{{$limbCount}} - (i + 1)] = binary.BigEndian.Uint64(val_bytes[i * 8: (i + 1) * 8])
	}

	return result
}

// does the Python equivalent of pow(-modulus, -1, 1<<64)
func MontConstant_{{$limbCount}}Limbs(modulus [{{$limbCount}}]uint64) uint64 {
	mod_int := LimbsToInt(modulus[:])
	
	// 1<<64
	aux_mod, _ := new(big.Int).SetString("18446744073709551616", 10)
	negative_one, _ := new(big.Int).SetString("-1", 10)

	mod_int.Mul(&mod_int, negative_one)
	return mod_int.ModInverse(&mod_int, aux_mod).Uint64()
}

func RSquared_{{$limbCount}}Limbs(modulus [{{$limbCount}}]uint64) [{{$limbCount}}]uint64 {
	mod := LimbsToInt(modulus[:])
	r := new(big.Int)
	r.Exp(big.NewInt(2), big.NewInt(4 * 64), &mod)
	r.Mul(r, r)
	r.Mod(r, &mod)
	return IntToLimbs_{{$limbCount}}Limbs(r)
}

func One_{{$limbCount}}Limbs() *[{{$limbCount}}]uint64 {
	one := {{ makeZeroedLimbs $limbCount}}
	one[0] = 1
	return &one
}

// test converting 3 to montgomery and back using MulModMont
/*
func TestMulModMontUnrolled_{{$limbCount}}limbs(t *testing.T) {
	test_val := {{ makeZeroedLimbs $limbCount}}
	test_val[0] = 3

	intermediate_val := {{ makeZeroedLimbs $limbCount}}

	mod := MaxModulus_{{$limbCount}}Limbs()
	mont_const := MontConstant_{{$limbCount}}Limbs(mod)
	r_squared := RSquared_{{$limbCount}}Limbs(mod)
	
	_MulModMont_{{$limbCount}}Limbs(&intermediate_val, &test_val, &r_squared, &mod, mont_const)

	if Eq_{{$limbCount}}Limbs(test_val, intermediate_val) {
		t.Fatalf("conversion to montgomery should modify test val")
	}

	_MulModMont_{{$limbCount}}Limbs(&intermediate_val, &intermediate_val, One_{{$limbCount}}Limbs(), &mod, mont_const)

	if !Eq_{{$limbCount}}Limbs(test_val, intermediate_val) {
		t.Fatalf("conversion back from montgomery failed")
	}
}
*/

func TestAddMod_{{$limbCount}}limbs(t *testing.T) {

}

func TestSubMod_{{$limbCount}}limbs(t *testing.T) {

}

// test converting 3 to montgomery and back using MulModMont
func BenchmarkMulModMontUnrolled_{{$limbCount}}limbs(b *testing.B) {
	test_val := make([]uint64, {{$limbCount}})
	test_val[0] = 3

	intermediate_val := {{ makeZeroedLimbs $limbCount}}

	mod := MaxModulus_{{$limbCount}}Limbs()
	mont_const := MontConstant_{{$limbCount}}Limbs(mod)
	r_squared := RSquared_{{$limbCount}}Limbs(mod)
	
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		_MulModMont_{{$limbCount}}Limbs(intermediate_val[:], test_val, r_squared[:], mod[:], mont_const)
	}
}
