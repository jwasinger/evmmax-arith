{{ $limbCount := .LimbCount}}
{{ $limbCountPlusOne := add .LimbCount 1}}
{{ $limbBits := .LimbBits}}

package mont_arith

import (
	"math/bits"
    "math/big"
    "unsafe"
    "errors"
    "fmt"
)

// madd0 hi = a*b + c (discards lo bits)
func madd0(a, b, c uint64) (uint64) {
	var carry, lo uint64
	hi, lo := bits.Mul64(a, b)
	_, carry = bits.Add64(lo, c, 0)
	hi, _ = bits.Add64(hi, 0, carry)
	return hi
}

// madd1 hi, lo = a*b + c
func madd1(a, b, c uint64) (uint64, uint64) {
	var carry uint64
	hi, lo := bits.Mul64(a, b)
	lo, carry = bits.Add64(lo, c, 0)
	hi, _ = bits.Add64(hi, 0, carry)
	return hi, lo
}

// madd2 hi, lo = a*b + c + d
func madd2(a, b, c, d uint64) (uint64, uint64) {
	var carry uint64
	hi, lo := bits.Mul64(a, b)
	c, carry = bits.Add64(c, d, 0)
	hi, _ = bits.Add64(hi, 0, carry)
	lo, carry = bits.Add64(lo, c, 0)
	hi, _ = bits.Add64(hi, 0, carry)
	return hi, lo
}

func madd3(a, b, c, d, e uint64) (uint64, uint64) {
	var carry uint64
    var c_uint uint64
	hi, lo := bits.Mul64(a, b)
	c_uint, carry = bits.Add64(c, d, 0)
	hi, _ = bits.Add64(hi, 0, carry)
	lo, carry = bits.Add64(lo, c_uint, 0)
	hi, _ = bits.Add64(hi, e, carry)
	return hi, lo
}

/*
 * begin mulmont implementations
 */

func mulMont64(f *Field, outBytes, xBytes, yBytes []byte) error {
	var product [2]uint64
	var c uint64
    mod := f.Modulus
    modinv := f.MontParamInterleaved

    x := (*[1]uint64)(unsafe.Pointer(&xBytes[0]))[:]
    y := (*[1]uint64)(unsafe.Pointer(&yBytes[0]))[:]
    out := (*[1]uint64)(unsafe.Pointer(&outBytes[0]))[:]

    if x[0] >= mod[0] || y[0] >= mod[0] {
        return errors.New(fmt.Sprintf("x/y gte modulus"))
    }

	product[1], product[0] = bits.Mul64(x[0], y[0])
	m := product[0] * modinv
	c, _ = madd1(m, mod[0], product[0])
	out[0] = c + product[1]

	if out[0] > mod[0] {
		out[0] = c - mod[0]
	}
    return nil
}
