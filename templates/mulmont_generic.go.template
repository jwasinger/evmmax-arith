// NOTE: this assumes that x and y are in Montgomery form and can produce unexpected results when they are not
func MulModMontNonInterleaved(f *Field, outLimbs, xLimbs, yLimbs nat) error {
	// length x == y assumed

	product := new(big.Int)
	x := LimbsToInt(xLimbs)
	y := LimbsToInt(yLimbs)

    /*
	if x.Cmp(f.ModulusNonInterleaved) > 0 || y.Cmp(f.ModulusNonInterleaved) > 0 {
		return errors.New("x/y >= modulus")
	}
    */

	// m <- ((x*y mod R)N`) mod R
	product.Mul(x, y)
	x.And(product, f.mask)
	x.Mul(x, f.MontParamNonInterleaved)
	x.And(x, f.mask)

	// t <- (T + mN) / R
	x.Mul(x, f.ModulusNonInterleaved)
	x.Add(x, product)
	x.Rsh(x, f.NumLimbs*64)

	if x.Cmp(f.ModulusNonInterleaved) >= 0 {
		x.Sub(x, f.ModulusNonInterleaved)
	}

    result := IntToLimbs(x, f.NumLimbs)
    for i := 0; i < int(f.NumLimbs); i++ {
        outLimbs[i] = result[i]
    }  

	return nil
}
