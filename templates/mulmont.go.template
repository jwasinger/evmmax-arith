{{ $limbCount := .LimbCount}}
{{ $lastLimb := sub $limbCount 1}}
{{ $limbBits := .LimbBits}}

func mulMont{{mul $limbCount $limbBits}}(ctx *Field, out_bytes, x_bytes, y_bytes []byte) (error) {
	x := (*[{{$limbCount}}]uint64)(unsafe.Pointer(&x_bytes[0]))[:]
	y := (*[{{$limbCount}}]uint64)(unsafe.Pointer(&y_bytes[0]))[:]
	z := (*[{{$limbCount}}]uint64)(unsafe.Pointer(&out_bytes[0]))[:]
	mod := (*[{{$limbCount}}]uint64)(unsafe.Pointer(&ctx.Modulus[0]))[:]
	var t [{{add $limbCount 1}}]uint64
	var D uint64
	var m, C uint64

    if GTE(x, mod) || GTE(y, mod) {
        return errors.New(fmt.Sprintf("input greater than or equal to modulus"))
    }

	{{- range $j := intRange 0 $limbCount}}
		// -----------------------------------
		// First loop
		{{ if eq $j 0}}
			C, t[0] = bits.Mul64(x[{{$j}}], y[0])
			{{- range $i := intRange 1 $limbCount}}
				C, t[{{$i}}] = madd1(x[{{$j}}], y[{{$i}}], C)
			{{- end}}
		{{ else }}
			C, t[0] = madd1(x[{{$j}}], y[0], t[0])
			{{- range $i := intRange 1 $limbCount }}
				C, t[{{$i}}] = madd2(x[{{$j}}], y[{{$i}}], t[{{$i}}], C)
			{{- end}}
		{{ end }}
		t[{{$limbCount}}], D = bits.Add64(t[{{$limbCount}}], C, 0)
		// m = t[0]n'[0] mod W
		m = t[0] * ctx.MontParamInterleaved
		// -----------------------------------
		// Second loop
		C = madd0(m, mod[0], t[0])
		{{- range $i := intRange 1 $limbCount}}
				C, t[{{sub $i 1}}] = madd2(m, mod[{{$i}}], t[{{$i}}], C)
		{{- end}}
		t[{{sub $limbCount 1}}], C = bits.Add64(t[{{$limbCount}}], C, 0)
		t[{{$limbCount}}], _ = bits.Add64(0, D, C)
	{{- end}}

    // TODO this shows up here, but I can't find reference to it in any paper
    // that references CIOS. is this just a quick hack for the final subtraction?
	if t[{{$limbCount}}] != 0 {
		// we need to reduce, we have a result on {{add 1 $limbCount}} words
		{{- if gt $limbCount 1}}
		var b uint64
		{{- end}}
		z[0], {{- if gt $limbCount 1}}b{{- else}}_{{- end}} = bits.Sub64(t[0], mod[0], 0)
		{{- range $i := intRange 1 $limbCount}}
			{{-  if eq $i $lastLimb}}
				z[{{$i}}], _ = bits.Sub64(t[{{$i}}], mod[{{$i}}], b)
			{{-  else  }}
				z[{{$i}}], b = bits.Sub64(t[{{$i}}], mod[{{$i}}], b)
			{{- end}}
		{{- end}}
		return nil
	}

	// copy t into z 
	{{- range $i := intRange 0 $limbCount }}
		z[{{$i}}] = t[{{$i}}]
	{{- end}}

	// final subtraction, overwriting z if z > mod
	if GTE(z, mod) {
		C = 0
		for i := 0; i < {{$limbCount}}; i++ {
			z[i], C = bits.Sub64(z[i], mod[i], C)
		}
	}

	return nil
}
